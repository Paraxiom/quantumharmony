<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumHarmony Node Operator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Rajdhani:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        /* ===========================================
           DESIGN SYSTEM - Based on 8px Grid
           Color Palette: 60/30/10 Rule
           =========================================== */
        :root {
            /* 60% - Background Colors */
            --bg-void: #000000;
            --bg-primary: #0c0c10;
            --bg-elevated: #14141a;
            --bg-surface: #1c1c24;

            /* 30% - Structural Colors (LCARS) */
            --lcars-gold: #f8a100;
            --lcars-gold-light: #ffc044;
            --lcars-gold-dark: #cc8400;
            --lcars-blue: #5c88da;
            --lcars-blue-light: #88aaff;

            /* 10% - Accent Colors */
            --accent-success: #22c997;
            --accent-danger: #ef5350;
            --accent-warning: #ffb74d;

            /* Text Colors - High Contrast */
            --text-primary: #ffffff;
            --text-secondary: #b0b0c0;
            --text-muted: #707080;
            --text-on-color: #0c0c10;

            /* Spacing Scale (8px base) */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 16px;
            --space-4: 24px;
            --space-5: 32px;
            --space-6: 48px;

            /* Typography Scale */
            --text-xs: 10px;
            --text-sm: 12px;
            --text-base: 14px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;

            /* Radii - LCARS characteristic */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-pill: 100px;
            --radius-lcars: 40px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            color: var(--text-primary);
            font-family: 'Rajdhani', system-ui, sans-serif;
            font-weight: 500;
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ===========================================
           LCARS FRAME STRUCTURE
           =========================================== */
        .lcars-frame {
            display: grid;
            grid-template-columns: 200px 1fr;
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            gap: 3px;
            padding: var(--space-2);
        }

        /* Header Bar */
        .lcars-header {
            grid-column: 1 / -1;
            display: flex;
            height: 72px;
        }

        .header-cap {
            width: 200px;
            background: var(--lcars-gold);
            border-radius: var(--radius-lcars) 0 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-3);
        }

        .header-cap img {
            height: 48px;
            width: auto;
            filter: brightness(0);
        }

        .header-bar {
            flex: 1;
            background: var(--lcars-gold);
            display: flex;
            align-items: center;
            padding: 0 var(--space-5);
        }

        .header-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--text-on-color);
            letter-spacing: 3px;
        }

        .header-end {
            width: 100px;
            background: var(--lcars-blue);
            border-radius: 0 var(--radius-lcars) 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-danger);
            box-shadow: 0 0 12px var(--accent-danger);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: var(--accent-success);
            box-shadow: 0 0 12px var(--accent-success);
        }

        /* Sidebar Navigation */
        .lcars-sidebar {
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            padding: var(--space-3) 0;
            border-radius: 0 0 0 var(--radius-lcars);
        }

        .sidebar-accent {
            height: 24px;
            background: var(--lcars-gold);
            margin: 0 var(--space-2) var(--space-4) var(--space-2);
            border-radius: var(--radius-pill);
        }

        .nav-btn {
            background: var(--lcars-gold-dark);
            border: none;
            color: var(--text-on-color);
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            font-weight: 600;
            padding: var(--space-3) var(--space-3);
            margin: 2px var(--space-2) 2px 0;
            border-radius: 0 var(--radius-pill) var(--radius-pill) 0;
            cursor: pointer;
            text-align: left;
            transition: background 0.15s ease;
            letter-spacing: 1px;
        }

        .nav-btn:hover {
            background: var(--lcars-gold);
        }

        .nav-btn.active {
            background: var(--accent-success);
        }

        .nav-spacer {
            flex: 1;
        }

        /* Main Content Area */
        .lcars-main {
            background: var(--bg-primary);
            border-radius: 0 0 var(--radius-lcars) 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-header {
            background: var(--lcars-gold);
            padding: var(--space-2) var(--space-4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-label {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--text-on-color);
            letter-spacing: 1px;
        }

        .content-area {
            flex: 1;
            padding: var(--space-4);
            overflow-y: auto;
        }

        /* Footer Bar */
        .lcars-footer {
            grid-column: 1 / -1;
            display: flex;
            height: 48px;
        }

        .footer-cap {
            width: 200px;
            background: var(--lcars-gold);
            border-radius: 0 0 0 var(--radius-lcars);
        }

        .footer-bar {
            flex: 1;
            background: var(--lcars-gold-dark);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--space-4);
        }

        .footer-text {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--text-on-color);
            letter-spacing: 1px;
        }

        .footer-end {
            width: 100px;
            background: var(--lcars-blue);
            border-radius: 0 0 var(--radius-lcars) 0;
        }

        /* ===========================================
           CONTENT COMPONENTS
           =========================================== */

        /* Panels */
        .panel { display: none; }
        .panel.active { display: block; }

        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--lcars-gold);
            padding-bottom: var(--space-2);
            margin-bottom: var(--space-4);
            border-bottom: 2px solid var(--lcars-gold-dark);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .stat-card {
            background: var(--bg-elevated);
            border-left: 4px solid var(--lcars-gold);
            padding: var(--space-3);
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
        }

        .stat-label {
            font-size: var(--text-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-1);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-value.blue { color: var(--lcars-blue-light); }
        .stat-value.green { color: var(--accent-success); }
        .stat-value.gold { color: var(--lcars-gold-light); }

        /* Section Title */
        .section-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin: var(--space-4) 0 var(--space-3) 0;
            padding-bottom: var(--space-2);
            border-bottom: 1px solid var(--bg-surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Buttons */
        .btn {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            font-weight: 600;
            padding: var(--space-2) var(--space-4);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: var(--lcars-gold);
            color: var(--text-on-color);
        }
        .btn-primary:hover { background: var(--lcars-gold-light); }

        .btn-success {
            background: var(--accent-success);
            color: var(--text-on-color);
        }
        .btn-success:hover { opacity: 0.9; }

        .btn-danger {
            background: var(--accent-danger);
            color: var(--text-primary);
        }
        .btn-danger:hover { opacity: 0.9; }

        .btn-secondary {
            background: var(--lcars-blue);
            color: var(--text-on-color);
        }
        .btn-secondary:hover { background: var(--lcars-blue-light); }

        .btn-sm {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
            flex-wrap: wrap;
            align-items: center;
        }

        /* Status Pill */
        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-elevated);
            border: 1px solid var(--accent-success);
            border-radius: var(--radius-pill);
            margin-left: auto;
        }

        .status-pill .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-success);
            animation: pulse 2s infinite;
        }

        .status-pill.offline {
            border-color: var(--accent-danger);
        }

        .status-pill.offline .dot {
            background: var(--accent-danger);
        }

        .status-pill-text {
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Info Box */
        .info-box {
            background: var(--bg-elevated);
            border: 1px solid var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-3);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--bg-surface);
            flex-wrap: wrap;
        }

        .info-row:last-child { border-bottom: none; }

        /* Recent block entry styling */
        .recent-block-entry {
            padding: 10px 0;
            border-bottom: 1px solid var(--bg-surface);
        }
        .recent-block-entry:last-child { border-bottom: none; }

        .info-label {
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        .info-value {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: var(--text-sm);
        }

        /* Terminal */
        .terminal {
            background: var(--bg-void);
            border: 1px solid var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            font-family: 'JetBrains Mono', monospace;
            font-size: var(--text-sm);
            color: var(--accent-success);
            max-height: 280px;
            overflow-y: auto;
        }

        .terminal-line {
            margin: var(--space-1) 0;
            line-height: 1.4;
        }

        .terminal-line.error { color: var(--accent-danger); }
        .terminal-line.warning { color: var(--accent-warning); }
        .terminal-line.info { color: var(--lcars-blue-light); }

        /* Forms */
        .form-group {
            margin-bottom: var(--space-3);
        }

        .form-label {
            display: block;
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-elevated);
            border: 2px solid var(--bg-surface);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: var(--text-base);
            transition: border-color 0.15s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--lcars-gold);
        }

        /* File Drop */
        .file-drop {
            border: 2px dashed var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-6);
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .file-drop:hover, .file-drop.dragover {
            border-color: var(--lcars-gold);
            background: rgba(248, 161, 0, 0.05);
        }

        .file-drop-icon {
            font-size: 48px;
            margin-bottom: var(--space-3);
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-4);
        }

        /* User Menu & Avatar Styles */
        .user-menu, .avatar-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--lcars-gold-dark);
            border-radius: var(--radius-md);
            min-width: 200px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .user-menu {
            left: 0;
            right: auto;
            margin-top: 8px;
        }

        .avatar-menu {
            margin-top: 8px;
        }

        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            transition: background 0.15s ease;
        }

        .menu-item:hover {
            background: var(--bg-surface);
            color: var(--text-primary);
        }

        .menu-divider {
            height: 1px;
            background: var(--bg-surface);
            margin: 4px 0;
        }

        .avatar-container {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .avatar-placeholder {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--lcars-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-family: 'Orbitron', monospace;
            transition: all 0.2s ease;
        }

        .avatar-placeholder:hover {
            border-color: var(--lcars-gold-light);
            transform: scale(1.05);
        }

        .avatar-placeholder img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Human Intervention Required Badge */
        .human-required {
            background: var(--accent-danger);
            color: white;
            padding: 2px 8px;
            border-radius: var(--radius-pill);
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive */
        @media (max-width: 900px) {
            .grid-2 { grid-template-columns: 1fr; }
            .lcars-frame { grid-template-columns: 140px 1fr; }
            .header-cap, .footer-cap { width: 140px; }
        }
    </style>
    <!-- Polkadot.js API for runtime upgrades -->
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/util@12.6.2/bundle-polkadot-util.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@12.6.2/bundle-polkadot-util-crypto.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/keyring@12.6.2/bundle-polkadot-keyring.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/api@10.13.1/bundle-polkadot-api.min.js"></script>
    <!-- QuantumHarmony Manager Modules -->
    <script src="js/upgrade-manager.js"></script>
    <script src="js/keystore-manager.js"></script>
    <script src="js/governance-manager.js"></script>
</head>
<body>
    <div class="lcars-frame">
        <!-- Header -->
        <div class="lcars-header">
            <div class="header-cap">
                <img src="logo.png" alt="Paraxiom">
            </div>
            <div class="header-bar">
                <span class="header-title">Node Operator...</span>
                <div class="header-menu" onclick="toggleUserMenu()" style="margin-left: 16px; cursor: pointer; padding: 4px 8px;">
                </div>
                <!-- User Menu Dropdown -->
                <div id="userMenu" class="user-menu" style="display: none;">
                    <div class="menu-item" onclick="showPanel('settings'); closeUserMenu();">Profile Settings</div>
                    <div class="menu-item" onclick="toggleAgentMode()">
                        <span>Agent Mode</span>
                        <span id="agentModeStatus" style="margin-left: auto; font-size: 10px; color: var(--accent-danger);">OFF</span>
                    </div>
                    <div class="menu-item" onclick="showPanel('keys'); closeUserMenu();">Manage Keys</div>
                    <div class="menu-divider"></div>
                    <div class="menu-item" style="color: var(--accent-warning);" onclick="closeUserMenu();">Disconnect</div>
                </div>
            </div>
            <div class="header-end" style="cursor: pointer; position: relative;" onclick="toggleAvatarMenu()">
                <div class="avatar-container" id="avatarContainer">
                    <div class="avatar-placeholder" id="avatarPlaceholder">
                        <span style="font-size: 18px;">?</span>
                    </div>
                </div>
                <!-- Avatar Menu -->
                <div id="avatarMenu" class="avatar-menu" style="display: none;">
                    <div style="padding: 12px; border-bottom: 1px solid var(--bg-surface);">
                        <div style="font-weight: 600; color: var(--text-primary);" id="operatorName">Anonymous Operator</div>
                        <div style="font-size: 10px; color: var(--text-muted);" id="operatorAddress">Not connected</div>
                    </div>
                    <div class="menu-item" onclick="uploadAvatar()">Upload Avatar</div>
                    <div class="menu-item" onclick="showPanel('settings'); closeAvatarMenu();">Account Settings</div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="lcars-sidebar">
            <div class="sidebar-accent"></div>
            <button class="nav-btn active" onclick="showPanel('status')">STATUS</button>
            <button class="nav-btn" onclick="showPanel('governance')">GOVERN</button>
            <button class="nav-btn" onclick="showPanel('rewards')">REWARDS</button>
            <button class="nav-btn" onclick="showPanel('qcad')">QCAD</button>
            <button class="nav-btn" onclick="showPanel('runtime')">RUNTIME</button>
            <button class="nav-btn" onclick="showPanel('keys')">KEYS</button>
            <button class="nav-btn" onclick="showPanel('quantum')">QUANTUM</button>
            <button class="nav-btn" onclick="showPanel('network')">NETWORK</button>
            <div class="nav-spacer"></div>
            <button class="nav-btn" onclick="showPanel('settings')">SETTINGS</button>
        </div>

        <!-- Main Content -->
        <div class="lcars-main">
            <div class="content-header">
                <span class="content-label">SYSTEM INTERFACE v1.0</span>
                <span class="content-label" id="timestamp">---</span>
            </div>
            <div class="content-area">

                <!-- STATUS PANEL -->
                <div id="panel-status" class="panel active">
                    <h2 class="panel-title">Node Status</h2>

                    <div class="control-bar">
                        <button class="btn btn-success" onclick="startNode()" id="startBtn">START</button>
                        <button class="btn btn-danger" onclick="stopNode()" id="stopBtn">STOP</button>
                        <button class="btn btn-primary" onclick="restartNode()" id="restartBtn">RESTART</button>
                        <div class="status-pill" id="nodeProcessStatus">
                            <div class="dot"></div>
                            <span class="status-pill-text" id="nodeProcessText">Unknown</span>
                        </div>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Block Height</div>
                            <div class="stat-value" id="blockHeight">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Connected Peers</div>
                            <div class="stat-value blue" id="peerCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Runtime</div>
                            <div class="stat-value green" id="runtimeVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Sync Status</div>
                            <div class="stat-value gold" id="syncStatus">---</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Node Information</span>
                        <button class="btn btn-secondary btn-sm" onclick="debugRPC()">DEBUG</button>
                        <button class="btn btn-secondary btn-sm" onclick="fetchNodeInfo()">REFRESH</button>
                    </div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Chain</span>
                            <span class="info-value" id="chainName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Node Name</span>
                            <span class="info-value" id="nodeName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Version</span>
                            <span class="info-value" id="nodeVersion">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">RPC Endpoint</span>
                            <span class="info-value" id="rpcEndpoint">---</span>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Recent Blocks</span>
                        <button class="btn btn-secondary btn-sm" onclick="refreshRecentBlocks()">REFRESH</button>
                    </div>
                    <div class="info-box" id="recentBlocksContainer" style="max-height: 200px; overflow-y: auto;">
                        <div class="recent-block" id="noBlocksMsg">
                            <span class="info-label">Loading recent blocks...</span>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearTerminal()">CLEAR</button>
                    </div>
                    <div class="terminal" id="terminal">
                        <div class="terminal-line info">System initialized</div>
                    </div>
                </div>

                <!-- GOVERNANCE PANEL -->
                <div id="panel-governance" class="panel">
                    <h2 class="panel-title">
                        Validator Governance
                        <span class="human-required" style="margin-left: 12px;">HUMAN REQUIRED</span>
                    </h2>

                    <!-- Human Intervention Notice -->
                    <div style="background: linear-gradient(135deg, rgba(239,83,80,0.1), rgba(248,161,0,0.1)); border: 1px solid var(--accent-warning); border-radius: var(--radius-md); padding: 16px; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                            <span style="font-size: 24px;">&#9888;</span>
                            <span style="font-family: 'Orbitron', monospace; font-size: 14px; color: var(--accent-warning);">ESSENTIAL HUMAN INTERVENTION</span>
                        </div>
                        <p style="font-size: 12px; color: var(--text-secondary); line-height: 1.6;">
                            Governance decisions cannot be automated. All proposals and votes require your direct action.
                            Agent Mode will <strong style="color: var(--text-primary);">never</strong> vote on your behalf - this protects network integrity and your validator stake.
                        </p>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Active Proposals</div>
                            <div class="stat-value gold" id="activeProposals">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Validators</div>
                            <div class="stat-value" id="validatorCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Voting Period</div>
                            <div class="stat-value blue" id="votingPeriod">10 blocks</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Min Votes Required</div>
                            <div class="stat-value green" id="minVotes">1</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Propose New Validator</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Validator Account (Public Key)</label>
                            <input type="text" class="form-input" id="proposeValidatorAccount" placeholder="0x...">
                        </div>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Your SPHINCS+ Secret Key</label>
                            <input type="password" class="form-input" id="proposeSigner" placeholder="0x... (your signing key)">
                        </div>
                        <button class="btn btn-success" onclick="proposeValidator()">SUBMIT PROPOSAL</button>
                    </div>

                    <div class="section-title">
                        <span>Active Proposals</span>
                        <button class="btn btn-secondary btn-sm" onclick="refreshProposals()">REFRESH</button>
                    </div>
                    <div id="proposalsList" class="info-box">
                        <div class="info-row" id="noProposalsMsg">
                            <span class="info-label">No active proposals. Click REFRESH to check.</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearGovConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="govTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Governance console ready</div>
                    </div>
                </div>

                <!-- REWARDS PANEL -->
                <div id="panel-rewards" class="panel">
                    <h2 class="panel-title">Validator Rewards</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Pending Rewards</div>
                            <div class="stat-value gold" id="pendingRewards">0 QHM</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Staked</div>
                            <div class="stat-value blue" id="totalStaked">0 QHM</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Certification</div>
                            <div class="stat-value" id="certLevel">Uncertified</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Reward Multiplier</div>
                            <div class="stat-value green" id="rewardMultiplier">70%</div>
                        </div>
                    </div>

                    <div class="section-title">Certification Levels</div>
                    <div class="grid-2" style="margin-bottom: 24px;">
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--text-muted);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Uncertified</span>
                                <span style="color: var(--accent-warning); margin-left: auto;">70% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Default level for new validators. Limited reward multiplier until verification.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--lcars-blue);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">KYC Verified</span>
                                <span style="color: var(--accent-success); margin-left: auto;">100% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Identity verified through KYC process. Full reward eligibility.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--lcars-gold);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Agent Certified</span>
                                <span style="color: var(--lcars-gold-light); margin-left: auto;">120% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Premium tier with bonus rewards. Requires additional certification.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--accent-danger);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Cooldown Period</span>
                                <span style="color: var(--accent-danger); margin-left: auto;">100 blocks</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Unstaking requires a cooldown period before funds are released.</p>
                        </div>
                    </div>

                    <div class="section-title">Staking Actions</div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="grid-2" style="gap: 16px;">
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Stake Amount (QHM)</label>
                                    <input type="number" class="form-input" id="stakeAmount" placeholder="1000">
                                </div>
                                <button class="btn btn-success" onclick="stakeTokens()">STAKE</button>
                            </div>
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Unstake Amount (QHM)</label>
                                    <input type="number" class="form-input" id="unstakeAmount" placeholder="1000">
                                </div>
                                <button class="btn btn-danger" onclick="requestUnstake()">REQUEST UNSTAKE</button>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Reward Actions</div>
                    <div style="display: flex; gap: 12px; margin-bottom: 24px;">
                        <button class="btn btn-primary" onclick="claimRewards()">CLAIM REWARDS</button>
                        <button class="btn btn-secondary" onclick="submitUptimeProof()">SUBMIT UPTIME PROOF</button>
                        <button class="btn btn-secondary" onclick="refreshRewards()">REFRESH</button>
                    </div>

                    <div class="section-title">
                        <span>Unstake Queue</span>
                    </div>
                    <div class="info-box" id="unstakeQueue">
                        <div class="info-row">
                            <span class="info-label">No pending unstake requests</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearRewardsConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="rewardsTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Rewards console ready</div>
                    </div>
                </div>

                <!-- RUNTIME PANEL -->
                <div id="panel-runtime" class="panel">
                    <h2 class="panel-title">Runtime Upgrade</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Spec Version</div>
                            <div class="stat-value green" id="specVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Impl Version</div>
                            <div class="stat-value" id="implVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Upgrade Method</div>
                            <div class="stat-value blue" id="upgradeMethod">Auto</div>
                        </div>
                    </div>

                    <div class="section-title">Sudo Key (Required)</div>
                    <div class="info-box" style="margin-bottom: 16px;">
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label class="form-label">Sudo Secret Key</label>
                            <input type="password" class="form-input" id="sudoSecretKey" placeholder="alice, bob, charlie, or paste 128-byte hex key">
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted);">
                            Dev accounts: <code style="color: var(--lcars-gold);">alice</code>, <code style="color: var(--lcars-gold);">bob</code>, <code style="color: var(--lcars-gold);">charlie</code> |
                            Production: paste full 128-byte SPHINCS+ secret key
                        </div>
                    </div>

                    <div class="section-title">Upload Runtime WASM</div>
                    <div class="file-drop" id="wasmDropZone" onclick="document.getElementById('wasmFile').click()">
                        <div class="file-drop-icon">ðŸ“¦</div>
                        <div style="font-size: 16px; margin-bottom: 8px;">Drop WASM file here</div>
                        <div style="font-size: 12px; color: var(--text-muted);">or click to browse</div>
                        <input type="file" id="wasmFile" accept=".wasm" style="display: none;" onchange="handleWasmSelect(this)">
                    </div>

                    <div class="info-box" id="wasmInfo" style="display: none; margin-top: 16px;">
                        <div class="info-row">
                            <span class="info-label">File</span>
                            <span class="info-value" id="wasmFileName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Size</span>
                            <span class="info-value" id="wasmFileSize">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">SHA256</span>
                            <span class="info-value" id="wasmHash" style="font-size: 10px;">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Method</span>
                            <span class="info-value" id="wasmMethod">---</span>
                        </div>
                    </div>

                    <!-- Progress Bar -->
                    <div id="upgradeProgress" style="display: none; margin-top: 16px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span id="progressPhase" style="font-size: 12px; color: var(--text-secondary);">Preparing...</span>
                            <span id="progressPercent" style="font-size: 12px; color: var(--lcars-gold);">0%</span>
                        </div>
                        <div style="height: 8px; background: var(--bg-surface); border-radius: 4px; overflow: hidden;">
                            <div id="progressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--lcars-gold), var(--accent-success)); transition: width 0.3s ease;"></div>
                        </div>
                        <div id="progressDetails" style="font-size: 11px; color: var(--text-muted); margin-top: 4px;"></div>
                    </div>

                    <div style="margin-top: 24px; display: flex; gap: 12px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="submitRuntimeUpgradeV2()" id="upgradeBtn">SUBMIT UPGRADE</button>
                        <button class="btn btn-secondary" onclick="submitRuntimeUpgradeV2(true)" id="chunkedBtn">CHUNKED UPGRADE</button>
                        <button class="btn btn-secondary" onclick="clearWasm()">CLEAR</button>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearRuntimeConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="runtimeTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Runtime console ready</div>
                    </div>
                </div>

                <!-- KEYS PANEL -->
                <div id="panel-keys" class="panel">
                    <h2 class="panel-title">Key Management</h2>

                    <div class="section-title">Key Storage Location</div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Keystore Path</span>
                            <span class="info-value" id="keystorePath" style="font-size: 11px;">~/Library/Application Support/quantumharmony/operator-keystore/</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Algorithm</span>
                            <span class="info-value">SPHINCS+-256s (Post-Quantum)</span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px; margin: 24px 0; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="checkKeystore()">CHECK KEYSTORE</button>
                        <button class="btn btn-success" onclick="generateKey()">GENERATE NEW KEY</button>
                    </div>

                    <div class="section-title">
                        <span>Validator Keys</span>
                        <span id="keysCount" style="color: var(--lcars-gold);">0 keys</span>
                    </div>
                    <div class="info-box" id="keysListBox">
                        <div class="info-row" id="noKeysMsg">
                            <span class="info-label">No keys found. Click CHECK KEYSTORE or GENERATE NEW KEY.</span>
                        </div>
                    </div>

                    <div class="section-title">Key Injection (Advanced)</div>
                    <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 12px; color: var(--text-muted);">
                        <strong style="color: var(--accent-warning);">Note:</strong> Dev seeds (Alice, Bob) generate random test keys.
                        For production, use GENERATE NEW KEY and register the public key with the network.
                    </div>
                    <div class="form-group">
                        <label class="form-label">Dev Seed (testing only)</label>
                        <input type="text" class="form-input" id="sudoSeed" placeholder="Alice, Bob, Charlie...">
                    </div>
                    <button class="btn btn-secondary" onclick="injectKey()">INJECT DEV KEY</button>

                    <div class="section-title" style="margin-top: 32px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearKeysConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="keysTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Keys console ready</div>
                    </div>
                </div>

                <!-- QCAD STABLECOIN PANEL -->
                <div id="panel-qcad" class="panel">
                    <h2 class="panel-title">QCAD Stablecoin Peg</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">CAD/USD Rate</div>
                            <div class="stat-value" id="cadUsdRate">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">QCAD Peg Target</div>
                            <div class="stat-value green" id="qcadPegTarget">1.0000 CAD</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Oracle Status</div>
                            <div class="stat-value" id="oracleStatus" style="color: var(--accent-success);">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Last Update</div>
                            <div class="stat-value blue" id="oracleLastUpdate">---</div>
                        </div>
                    </div>

                    <div class="section-title">Price Oracle Feed</div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Data Source</span>
                            <span class="info-value">Bank of Canada / Wise API</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Update Frequency</span>
                            <span class="info-value">Every 100 blocks (~10 min)</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Current CAD/USD</span>
                            <span class="info-value" id="currentCadUsd">Loading...</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">24h Change</span>
                            <span class="info-value" id="cadChange24h">---</span>
                        </div>
                    </div>

                    <div class="section-title">Peg Mechanism</div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Algorithm</span>
                            <span class="info-value">Algorithmic + Reserve Backed</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Deviation Threshold</span>
                            <span class="info-value">0.5%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Rebalance Trigger</span>
                            <span class="info-value" id="rebalanceStatus">Normal</span>
                        </div>
                    </div>

                    <div class="section-title">Recent Price History</div>
                    <div style="background: var(--bg-surface); border-radius: var(--radius-md); padding: var(--space-3); margin-bottom: var(--space-3);">
                        <canvas id="qcadPriceChart" width="600" height="200" style="width: 100%; max-width: 600px; display: block; margin: 0 auto; border-radius: var(--radius-sm);"></canvas>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-primary" onclick="refreshQcadData()">REFRESH ORACLE</button>
                        <button class="btn btn-secondary" onclick="viewOracleHistory()">VIEW HISTORY</button>
                    </div>
                </div>

                <!-- QUANTUM PANEL -->
                <div id="panel-quantum" class="panel">
                    <h2 class="panel-title">Quantum Services</h2>

                    <div class="section-title">Entropy Source</div>
                    <div class="form-group">
                        <select class="form-input" id="entropySource" onchange="onEntropySourceChange()">
                            <option value="hub">Entropy Hub (Aggregator)</option>
                            <option value="crypto4a">Crypto4A QRNG</option>
                            <option value="qkd">QKD Device</option>
                        </select>
                    </div>

                    <div class="grid-2">
                        <div>
                            <div class="section-title">QKD Client</div>
                            <div class="status-pill" id="qkdStatus" style="margin-bottom: 16px;">
                                <div class="dot"></div>
                                <span class="status-pill-text" id="qkdStatusText">Checking...</span>
                            </div>
                            <div class="info-box">
                                <div class="info-row">
                                    <span class="info-label">Device</span>
                                    <span class="info-value" id="qkdDevice">---</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Keys Available</span>
                                    <span class="info-value" id="qkdKeys">---</span>
                                </div>
                            </div>
                        </div>

                        <div>
                            <div class="section-title">Entropy Hub</div>
                            <div class="status-pill" id="hubStatus" style="margin-bottom: 16px;">
                                <div class="dot"></div>
                                <span class="status-pill-text" id="hubStatusText">Checking...</span>
                            </div>
                            <div class="info-box">
                                <div class="info-row">
                                    <span class="info-label">Active Sources</span>
                                    <span class="info-value" id="hubSources">---</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Pool Size</span>
                                    <span class="info-value" id="hubPool">---</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Crypto4A HSM (QRNG/RNG Entropy)</div>
                    <div class="info-box" id="crypto4aRngBox">
                        <div class="info-row">
                            <span class="info-label">Description</span>
                            <span class="info-value" style="font-size: 11px; color: var(--text-muted);">Hardware entropy source (does not store keys)</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Endpoint</span>
                            <input type="text" class="form-input" id="crypto4aEndpoint" value="http://localhost:8106/v1/random" style="margin-top: 8px;">
                        </div>
                        <div class="info-row">
                            <span class="info-label">Status</span>
                            <span class="info-value" id="crypto4aStatus">Not Tested</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Last Entropy</span>
                            <span class="info-value" id="crypto4aEntropy" style="font-size: 10px;">---</span>
                        </div>
                    </div>
                    <div style="margin-top: 16px; display: flex; gap: 12px;">
                        <button class="btn btn-primary" onclick="testCrypto4aRng()">TEST RNG</button>
                        <button class="btn btn-secondary" onclick="fetchCrypto4aEntropy(32)">FETCH 32 BYTES</button>
                    </div>
                </div>

                <!-- NETWORK PANEL -->
                <div id="panel-network" class="panel">
                    <h2 class="panel-title">Network Topology</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Connected Peers</div>
                            <div class="stat-value blue" id="networkPeers">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Best Block</div>
                            <div class="stat-value" id="networkBest">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Finalized</div>
                            <div class="stat-value green" id="networkFinalized">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Network Health</div>
                            <div class="stat-value" id="networkHealth" style="color: var(--accent-success);">---</div>
                        </div>
                    </div>

                    <div class="section-title">Toroidal Mesh Topology</div>
                    <div style="background: var(--bg-surface); border-radius: var(--radius-md); padding: var(--space-3); margin-bottom: var(--space-3);">
                        <canvas id="networkCanvas" width="600" height="400" style="width: 100%; max-width: 600px; display: block; margin: 0 auto; border-radius: var(--radius-sm);"></canvas>
                    </div>

                    <div class="section-title">Validator Nodes</div>
                    <div id="validatorNodes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-3);">
                        <!-- Validator cards will be populated by JS -->
                    </div>

                    <div class="section-title" style="margin-top: var(--space-4);">Peer Connections</div>
                    <div class="info-box" id="peersList" style="max-height: 200px; overflow-y: auto;">
                        <div class="info-row">
                            <span class="info-label">Fetching peers...</span>
                        </div>
                    </div>
                </div>

                <!-- SETTINGS PANEL -->
                <div id="panel-settings" class="panel">
                    <h2 class="panel-title">Settings</h2>

                    <div class="form-group">
                        <label class="form-label">RPC Endpoint</label>
                        <input type="text" class="form-input" id="settingsRpc" value="http://localhost:9944">
                    </div>
                    <div class="form-group">
                        <label class="form-label">QKD Endpoint</label>
                        <input type="text" class="form-input" id="settingsQkd" value="http://localhost:8181">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Entropy Hub</label>
                        <input type="text" class="form-input" id="settingsHub" value="http://localhost:8180">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Controller</label>
                        <input type="text" class="form-input" id="settingsController" value="http://localhost:9955">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Console Log Level</label>
                        <select class="form-input" id="settingsLogLevel" onchange="setLogLevel(parseInt(this.value))">
                            <option value="0">Errors Only</option>
                            <option value="1" selected>Info (default)</option>
                            <option value="2">Verbose (all RPC)</option>
                        </select>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-primary" onclick="saveSettings()">SAVE</button>
                        <button class="btn btn-secondary" onclick="loadSettings()">RESET</button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Footer -->
        <div class="lcars-footer">
            <div class="footer-cap"></div>
            <div class="footer-bar">
                <span class="footer-text" id="footerStatus">Disconnected</span>
            </div>
            <div class="footer-end"></div>
        </div>
    </div>

    <script>
        // Configuration - auto-detect RPC endpoint based on page location
        // Force clear bad cache if ?reset in URL
        if (window.location.search.includes('reset')) {
            localStorage.clear();
            window.location.href = window.location.pathname;
        }

        // Use nginx proxy to avoid CORS issues
        const RPC_URL = '/rpc';

        let config = {
            rpc: RPC_URL,
            qkd: 'http://localhost:8181',
            hub: 'http://localhost:8180',
            controller: window.location.origin
        };

        let connected = false;
        let selectedWasm = null;
        let sudoAccount = null;
        let agentModeEnabled = localStorage.getItem('agentMode') === 'true';

        // ===========================================
        // USER MENU & AVATAR FUNCTIONS
        // ===========================================

        function toggleUserMenu() {
            const menu = document.getElementById('userMenu');
            const avatarMenu = document.getElementById('avatarMenu');
            avatarMenu.style.display = 'none';
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            event.stopPropagation();
        }

        function closeUserMenu() {
            document.getElementById('userMenu').style.display = 'none';
        }

        function toggleAvatarMenu() {
            const menu = document.getElementById('avatarMenu');
            const userMenu = document.getElementById('userMenu');
            userMenu.style.display = 'none';
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            event.stopPropagation();
        }

        function closeAvatarMenu() {
            document.getElementById('avatarMenu').style.display = 'none';
        }

        // Close menus when clicking outside
        document.addEventListener('click', () => {
            closeUserMenu();
            closeAvatarMenu();
        });

        function uploadAvatar() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const placeholder = document.getElementById('avatarPlaceholder');
                        placeholder.innerHTML = `<img src="${ev.target.result}" alt="Avatar">`;
                        localStorage.setItem('avatar', ev.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
            closeAvatarMenu();
        }

        // Load saved avatar on init
        function loadAvatar() {
            const saved = localStorage.getItem('avatar');
            if (saved) {
                document.getElementById('avatarPlaceholder').innerHTML = `<img src="${saved}" alt="Avatar">`;
            }
        }

        // ===========================================
        // AGENT MODE FUNCTIONS
        // ===========================================

        function toggleAgentMode() {
            agentModeEnabled = !agentModeEnabled;
            localStorage.setItem('agentMode', agentModeEnabled);
            updateAgentModeUI();
            closeUserMenu();

            if (agentModeEnabled) {
                log('AGENT MODE ENABLED - Auto-stake active, governance requires manual intervention', 'warning');
            } else {
                log('Agent Mode disabled - Full manual control', 'info');
            }
        }

        function updateAgentModeUI() {
            // Agent Mode is stealth - only show status in private menu
            // No public banner to prevent strategy revelation
            const statusEl = document.getElementById('agentModeStatus');

            if (agentModeEnabled) {
                statusEl.textContent = 'ON';
                statusEl.style.color = 'var(--accent-success)';
            } else {
                statusEl.textContent = 'OFF';
                statusEl.style.color = 'var(--accent-danger)';
            }
        }

        // Auto-stake check (runs when agent mode is enabled)
        async function checkAutoStake() {
            if (!agentModeEnabled) return;

            // In agent mode, automatically compound rewards
            // Note: This does NOT vote - governance always requires human
            rewardsLog('Agent Mode: Checking for auto-stake opportunities...', 'info');
            // Would call the staking RPC here
        }

        // Log level: 0=errors only, 1=info, 2=verbose (shows all RPC)
        let logLevel = parseInt(localStorage.getItem('logLevel') || '1');

        function setLogLevel(level) {
            logLevel = level;
            localStorage.setItem('logLevel', level);
            log(`Log level set to ${['errors', 'info', 'verbose'][level]}`, 'info');
        }

        // RPC endpoint - same pattern as working wallet
        const RPC = '/rpc';

        async function rpc(method, params = []) {
            try {
                const res = await fetch(RPC, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
                });
                const data = await res.json();
                if (data.error) {
                    console.error('RPC error:', data.error);
                    return null;
                }
                return data.result;
            } catch (e) {
                console.error('RPC fetch error:', method, e);
                return null;
            }
        }

        // Controller Helper
        async function controllerRequest(endpoint, method = 'GET', body = null) {
            try {
                const options = { method, headers: { 'Content-Type': 'application/json' } };
                if (method === 'POST') options.body = body ? JSON.stringify(body) : '{}';
                const res = await fetch(config.controller + endpoint, options);
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        // Node Control
        async function startNode() {
            log('Starting node...', 'warning');
            document.getElementById('startBtn').disabled = true;
            const result = await controllerRequest('/node/start', 'POST');
            document.getElementById('startBtn').disabled = false;
            if (result?.success) {
                log(`Node started (PID: ${result.pid})`, 'info');
            } else {
                log(result?.message || 'Failed to start', 'error');
            }
            updateNodeProcessStatus();
        }

        async function stopNode() {
            log('Stopping node...', 'warning');
            const result = await controllerRequest('/node/stop', 'POST');
            log(result?.success ? 'Node stopped' : (result?.message || 'Failed'), result?.success ? 'info' : 'error');
            updateNodeProcessStatus();
        }

        async function restartNode() {
            log('Restarting node...', 'warning');
            const result = await controllerRequest('/node/restart', 'POST');
            if (result?.success) log(`Node restarted (PID: ${result.pid})`, 'info');
            else log(result?.message || 'Failed', 'error');
            updateNodeProcessStatus();
        }

        async function updateNodeProcessStatus() {
            // Try direct RPC first (preferred - works without controller)
            console.log('[updateNodeProcessStatus] Checking...');
            const health = await rpc('system_health');
            console.log('[updateNodeProcessStatus] Health result:', health);
            const pill = document.getElementById('nodeProcessStatus');
            const text = document.getElementById('nodeProcessText');

            if (health) {
                console.log('[updateNodeProcessStatus] Node is healthy, will call fetchNodeInfo');
                log(`Node healthy: ${health.peers} peers`, 'info');
                pill.classList.remove('offline');
                text.textContent = 'Running';

                // Get block height
                const header = await rpc('chain_getHeader');
                if (header?.number) {
                    const blockNum = parseInt(header.number, 16);
                    document.getElementById('blockHeight').textContent = blockNum.toLocaleString();
                    document.getElementById('networkBest').textContent = blockNum.toLocaleString();
                }

                // Set peers from health
                document.getElementById('peerCount').textContent = health.peers;
                document.getElementById('networkPeers').textContent = health.peers;

                // Set sync status
                document.getElementById('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced';

                // Update connected status
                connected = true;
                document.getElementById('statusDot').classList.add('connected');
                document.getElementById('footerStatus').textContent = 'Connected';

                // Fetch additional node info via RPC
                await fetchNodeInfo();
            } else {
                pill.classList.add('offline');
                text.textContent = 'Offline';
                connected = false;
                document.getElementById('statusDot').classList.remove('connected');
                document.getElementById('footerStatus').textContent = 'Disconnected';
            }
        }

        // Small delay helper
        const delay = ms => new Promise(r => setTimeout(r, ms));

        // Debug function to test RPC directly
        async function debugRPC() {
            const url = config.rpc;
            log(`DEBUG: Testing RPC at ${url}`, 'warning');

            const results = [];

            try {
                // Test 1: system_chain
                log('DEBUG: Testing system_chain...', 'info');
                const res1 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'system_chain', params: [] })
                });
                const data1 = await res1.json();
                results.push(`system_chain: ${data1.result || data1.error?.message || 'failed'}`);
                log(`DEBUG: system_chain = ${data1.result || 'ERROR'}`, data1.result ? 'info' : 'error');

                if (data1.result) {
                    document.getElementById('chainName').textContent = data1.result;
                }
            } catch (e) {
                results.push(`system_chain: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_chain FETCH ERROR: ${e.message}`, 'error');
            }

            await delay(100);

            try {
                // Test 2: system_name
                log('DEBUG: Testing system_name...', 'info');
                const res2 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 2, method: 'system_name', params: [] })
                });
                const data2 = await res2.json();
                results.push(`system_name: ${data2.result || data2.error?.message || 'failed'}`);
                log(`DEBUG: system_name = ${data2.result || 'ERROR'}`, data2.result ? 'info' : 'error');

                if (data2.result) {
                    document.getElementById('nodeName').textContent = data2.result;
                }
            } catch (e) {
                results.push(`system_name: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_name FETCH ERROR: ${e.message}`, 'error');
            }

            await delay(100);

            try {
                // Test 3: system_version
                log('DEBUG: Testing system_version...', 'info');
                const res3 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 3, method: 'system_version', params: [] })
                });
                const data3 = await res3.json();
                results.push(`system_version: ${data3.result || data3.error?.message || 'failed'}`);
                log(`DEBUG: system_version = ${data3.result || 'ERROR'}`, data3.result ? 'info' : 'error');

                if (data3.result) {
                    document.getElementById('nodeVersion').textContent = data3.result;
                }
            } catch (e) {
                results.push(`system_version: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_version FETCH ERROR: ${e.message}`, 'error');
            }

            document.getElementById('rpcEndpoint').textContent = url;

            log('DEBUG: Complete. Check Console Output above.', 'warning');
            alert('DEBUG Results:\\n\\n' + results.join('\\n') + '\\n\\nRPC URL: ' + url);
        }

        // Fetch node info (chain, name, version, runtime) via RPC
        async function fetchNodeInfo() {
            console.log('[fetchNodeInfo] Starting...');
            log(`Fetching node info...`, 'info');
            try {
                // Fetch sequentially with small delays to avoid overwhelming RPC
                const chain = await rpc('system_chain');
                await delay(100);

                const name = await rpc('system_name');
                await delay(100);

                const version = await rpc('system_version');
                await delay(100);

                const runtime = await rpc('state_getRuntimeVersion');

                console.log('[fetchNodeInfo] Results:', { chain, name, version, runtime });

                if (chain) {
                    document.getElementById('chainName').textContent = chain;
                    log(`Chain: ${chain}`, 'info');
                } else {
                    log('Chain: failed to fetch', 'error');
                }
                if (name) document.getElementById('nodeName').textContent = name;
                if (version) document.getElementById('nodeVersion').textContent = version;
                if (runtime && runtime.specName) {
                    document.getElementById('runtimeVersion').textContent = `v${runtime.specVersion}`;
                    log(`Runtime: v${runtime.specVersion}`, 'info');
                }
                document.getElementById('rpcEndpoint').textContent = config.rpc;

                // Refresh recent blocks after a short delay
                await delay(200);
                await refreshRecentBlocks();
            } catch (e) {
                log(`fetchNodeInfo error: ${e.message}`, 'error');
                console.error('[fetchNodeInfo] error:', e);
            }
        }

        // Terminal
        function log(message, type = 'info') {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 100) terminal.removeChild(terminal.firstChild);
        }

        function clearTerminal() {
            document.getElementById('terminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        // Navigation
        function showPanel(name) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('panel-' + name).classList.add('active');
            event.target.classList.add('active');
        }

        // Status Updates
        async function updateStatus() {
            try {
                const health = await rpc('system_health');
                const header = await rpc('chain_getHeader');
                const chain = await rpc('system_chain');
                const name = await rpc('system_name');
                const version = await rpc('system_version');
                const runtime = await rpc('state_getRuntimeVersion');

                if (health) {
                    connected = true;
                    document.getElementById('statusDot').classList.add('connected');
                    document.getElementById('footerStatus').textContent = 'Connected';
                    document.getElementById('peerCount').textContent = health.peers || 0;
                    document.getElementById('networkPeers').textContent = health.peers || 0;
                    document.getElementById('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced';
                } else {
                    connected = false;
                    document.getElementById('statusDot').classList.remove('connected');
                    document.getElementById('footerStatus').textContent = 'Disconnected';
                }

                if (header) {
                    const blockNum = parseInt(header.number, 16);
                    document.getElementById('blockHeight').textContent = blockNum.toLocaleString();
                    document.getElementById('networkBest').textContent = blockNum.toLocaleString();
                }

                // Node Information
                if (chain) document.getElementById('chainName').textContent = chain;
                if (name) document.getElementById('nodeName').textContent = name;
                if (version) document.getElementById('nodeVersion').textContent = version;

                // Runtime version - show spec version number
                if (runtime && runtime.specName) {
                    document.getElementById('runtimeVersion').textContent = `v${runtime.specVersion}`;
                    const specEl = document.getElementById('specVersion');
                    const implEl = document.getElementById('implVersion');
                    if (specEl) specEl.textContent = runtime.specVersion;
                    if (implEl) implEl.textContent = runtime.implVersion;
                }

                document.getElementById('rpcEndpoint').textContent = config.rpc;
                document.getElementById('timestamp').textContent = new Date().toLocaleString();

                // Fetch recent blocks on status update
                await refreshRecentBlocks();

                // Fetch and display peers
                await updatePeersList();
            } catch (e) {
                console.error('Status update error:', e);
            }
        }

        // Known validator mapping
        const KNOWN_VALIDATORS = {
            '12D3KooWDfWxmSK2Dz2GfrjgjPbGcQECC3noAGK49SWLvbYcR3DT': { name: 'Alice', ip: '51.79.26.123' },
            '12D3KooWSWt1tNoYPTGjLc4NciowWjsXqRUcEXJLB9X8uC4oKc6L': { name: 'Bob', ip: '51.79.26.168' },
            '12D3KooWJJiAaXrKFufa6FcUmCWT7eihdBRPsiQXCEDVg8yf3ZwH': { name: 'Charlie', ip: '209.38.225.4' },
            '12D3KooWH93miqFA3KPsSjgFpwJdGw4WgnPxaLrmShPB6bbUFfWQ': { name: 'Alice', ip: '51.79.26.123' },
            '12D3KooWCcC6Qqjzoe34tGkFSMkSvef27FkdFjd7krzgvqAa78jV': { name: 'Bob', ip: '51.79.26.168' },
        };

        async function updatePeersList() {
            try {
                const peers = await rpc('system_peers');
                const container = document.getElementById('validatorsList');
                if (!container || !peers) return;

                let html = '';
                for (const peer of peers) {
                    const peerId = peer.peerId;
                    const shortId = peerId.substring(0, 16) + '...';
                    const known = KNOWN_VALIDATORS[peerId];
                    const name = known ? known.name : 'Unknown';
                    const ip = known ? known.ip : 'external';
                    const role = peer.roles || 'FULL';
                    const bestBlock = peer.bestNumber || 0;
                    const isAuthority = role.includes('AUTHORITY');

                    html += `
                        <div class="info-row" style="border-bottom: 1px solid var(--bg-surface); padding: 8px 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="color: ${isAuthority ? 'var(--lcars-gold)' : 'var(--text-secondary)'}; font-weight: 600;">
                                        ${name}
                                    </span>
                                    <span style="color: var(--text-muted); font-size: 11px; margin-left: 8px;">
                                        ${ip}
                                    </span>
                                </div>
                                <div style="text-align: right;">
                                    <span style="color: ${isAuthority ? 'var(--accent-success)' : 'var(--text-secondary)'}; font-size: 11px;">
                                        ${role}
                                    </span>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                                <span style="color: var(--text-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                                    ${shortId}
                                </span>
                                <span style="color: var(--lcars-blue); font-size: 11px;">
                                    Block #${bestBlock.toLocaleString()}
                                </span>
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html || '<div class="info-row"><span class="info-label">No peers connected</span></div>';
            } catch (e) {
                console.error('updatePeersList error:', e);
            }
        }

        // Recent Blocks with Extrinsics
        let recentBlocks = [];

        async function refreshRecentBlocks() {
            console.log('[refreshRecentBlocks] Starting...');
            const container = document.getElementById('recentBlocksContainer');
            if (!container) {
                console.error('[refreshRecentBlocks] Container not found!');
                return;
            }

            try {
                const header = await rpc('chain_getHeader');
                console.log('[refreshRecentBlocks] Header:', header);
                if (!header) {
                    container.innerHTML = '<div class="info-row"><span class="info-label">Waiting for node connection...</span></div>';
                    return;
                }

                const currentBlock = parseInt(header.number, 16);
                const blocksToFetch = 5;

                let html = '';
                for (let i = 0; i < blocksToFetch; i++) {
                    const blockNum = currentBlock - i;
                    if (blockNum < 0) break;

                    const blockHash = await rpc('chain_getBlockHash', [blockNum]);
                    if (blockHash) {
                        const block = await rpc('chain_getBlock', [blockHash]);
                        if (block && block.block) {
                            const extrinsicsCount = block.block.extrinsics ? block.block.extrinsics.length : 0;

                            html += `
                                <div class="info-row" style="padding: 8px 0; border-bottom: 1px solid var(--bg-surface);">
                                    <div style="display: flex; justify-content: space-between; width: 100%;">
                                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 13px;">
                                            #${blockNum.toLocaleString()}
                                        </span>
                                        <span style="color: var(--accent-success); font-size: 12px;">
                                            ${extrinsicsCount} extrinsic${extrinsicsCount !== 1 ? 's' : ''}
                                        </span>
                                    </div>
                                    <div style="width: 100%; margin-top: 4px;">
                                        <span style="color: var(--text-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                                            ${blockHash.substring(0, 18)}...${blockHash.substring(blockHash.length - 8)}
                                        </span>
                                    </div>
                                </div>
                            `;
                        }
                    }
                }

                container.innerHTML = html || '<div class="info-row"><span class="info-label">No blocks found</span></div>';
            } catch (e) {
                console.error('Recent blocks error:', e);
                container.innerHTML = '<div class="info-row"><span class="info-label">Error loading blocks</span></div>';
            }
        }

        // WASM
        function handleWasmSelect(input) {
            const file = input.files[0];
            if (!file) return;
            selectedWasm = file;
            document.getElementById('wasmInfo').style.display = 'block';
            document.getElementById('wasmFileName').textContent = file.name;
            document.getElementById('wasmFileSize').textContent = (file.size / 1024).toFixed(2) + ' KB';
            document.getElementById('upgradeBtn').disabled = false;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const hash = await crypto.subtle.digest('SHA-256', e.target.result);
                const hex = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('wasmHash').textContent = '0x' + hex.substring(0, 32) + '...';
            };
            reader.readAsArrayBuffer(file);
            log(`WASM selected: ${file.name}`, 'info');
        }

        function clearWasm() {
            selectedWasm = null;
            document.getElementById('wasmFile').value = '';
            document.getElementById('wasmInfo').style.display = 'none';
            document.getElementById('upgradeBtn').disabled = true;
        }

        // Drag and drop
        const dropZone = document.getElementById('wasmDropZone');
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file?.name.endsWith('.wasm')) {
                document.getElementById('wasmFile').files = e.dataTransfer.files;
                handleWasmSelect(document.getElementById('wasmFile'));
            }
        });

        async function submitRuntimeUpgrade() {
            console.log('submitRuntimeUpgrade called');
            log('Starting runtime upgrade...', 'info');

            if (!selectedWasm) {
                log('No WASM file selected', 'error');
                alert('Please select a WASM file first');
                return;
            }

            // Check for sudo key - either from input or stored
            const sudoKeyInput = document.getElementById('sudoSecretKey')?.value ||
                                 document.getElementById('sudoSeed')?.value;

            if (!sudoKeyInput) {
                log('No sudo key configured', 'error');
                alert('Please enter sudo secret key in KEYS section.\n\nFor dev: use alice, bob, or charlie\nFor production: paste the full 128-byte hex key');
                return;
            }

            const btn = document.getElementById('upgradeBtn');
            btn.disabled = true;
            btn.textContent = 'SUBMITTING...';

            try {
                // Read WASM file as hex
                log('Reading WASM file...', 'info');
                const wasmBytes = await selectedWasm.arrayBuffer();
                const wasmHex = '0x' + Array.from(new Uint8Array(wasmBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                log(`WASM size: ${(wasmBytes.byteLength / 1024).toFixed(2)} KB`, 'info');

                // Determine the secret key to use
                let secretKeyHex;
                let keyInput = sudoKeyInput.trim().replace(/['"]/g, ''); // Remove quotes
                const keyLower = keyInput.toLowerCase();

                // Check if it's a dev account name
                if (keyLower === 'alice' || keyLower === '//alice') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.alice;
                    log('Using Alice dev account', 'info');
                } else if (keyLower === 'bob' || keyLower === '//bob') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.bob;
                    log('Using Bob dev account', 'info');
                } else if (keyLower === 'charlie' || keyLower === '//charlie') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.charlie;
                    log('Using Charlie dev account', 'info');
                } else {
                    // Treat as hex key - strip 0x prefix if present, then add it back
                    let hexPart = keyInput.startsWith('0x') ? keyInput.slice(2) : keyInput;
                    // Remove any non-hex characters (spaces, newlines, etc)
                    hexPart = hexPart.replace(/[^0-9a-fA-F]/g, '');

                    if (hexPart.length >= 96) {  // At least 48 bytes (seed) or 128 bytes (full key)
                        secretKeyHex = '0x' + hexPart;
                        log(`Using provided key (${hexPart.length / 2} bytes)`, 'info');
                    } else {
                        throw new Error(`Key too short: ${hexPart.length / 2} bytes. Need 48 (seed) or 128 (full key).`);
                    }
                }

                log('Calling quantumharmony_submitRuntimeUpgrade RPC...', 'warning');
                btn.textContent = 'SENDING TO NODE...';

                // Call the custom RPC endpoint
                console.log('RPC call: quantumharmony_submitRuntimeUpgrade');
                console.log('WASM hex length:', wasmHex.length);
                console.log('Secret key length:', secretKeyHex.length);

                let result;
                try {
                    result = await rpc('quantumharmony_submitRuntimeUpgrade', [wasmHex, secretKeyHex]);
                    console.log('RPC result:', result);
                } catch (rpcError) {
                    console.error('RPC error:', rpcError);
                    throw new Error(`RPC failed: ${rpcError.message || rpcError}`);
                }

                if (result) {
                    log('SUCCESS: Runtime upgrade submitted!', 'info');
                    log(`Transaction hash: ${result}`, 'info');
                    btn.textContent = 'SUCCESS!';
                    btn.style.background = 'var(--accent-success)';

                    // Show success alert
                    alert(`Runtime upgrade submitted successfully!\n\nTransaction: ${result}\n\nWaiting for finalization (~12 seconds)...`);

                    // Wait for a few blocks then refresh
                    log('Waiting for finalization (2 blocks)...', 'info');
                    setTimeout(() => {
                        updateStatus();
                        fetchNodeInfo();
                        log('Status refreshed - check spec_version for new version', 'info');
                        alert('Runtime upgrade should now be active. Check the spec_version in STATUS tab.');
                    }, 12000);  // Wait ~2 blocks
                } else {
                    throw new Error('RPC returned empty result - check node logs');
                }

            } catch (error) {
                log(`FAILED: ${error.message}`, 'error');
                console.error('Runtime upgrade error:', error);
                btn.textContent = 'FAILED';
                btn.style.background = 'var(--accent-danger)';
                alert(`Runtime upgrade FAILED!\n\n${error.message}\n\nCheck console for details.`);

                // Reset button after 3 seconds
                setTimeout(() => {
                    btn.style.background = '';
                    btn.textContent = 'SUBMIT UPGRADE';
                }, 3000);
            } finally {
                btn.disabled = false;
            }
        }

        // ============================================
        // RUNTIME UPGRADE V2 - Using UpgradeManager
        // ============================================

        // Runtime console helper
        function runtimeLog(message, type = 'info') {
            const terminal = document.getElementById('runtimeTerminal');
            if (!terminal) return;
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearRuntimeConsole() {
            const terminal = document.getElementById('runtimeTerminal');
            if (terminal) terminal.innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        function updateUpgradeProgress(progressData) {
            const progressDiv = document.getElementById('upgradeProgress');
            const progressBar = document.getElementById('progressBar');
            const progressPhase = document.getElementById('progressPhase');
            const progressPercent = document.getElementById('progressPercent');
            const progressDetails = document.getElementById('progressDetails');

            if (progressDiv) progressDiv.style.display = 'block';
            if (progressBar) progressBar.style.width = `${progressData.progress || 0}%`;
            if (progressPercent) progressPercent.textContent = `${Math.round(progressData.progress || 0)}%`;

            const phaseLabels = {
                preparing: 'Preparing...',
                initiating: 'Initiating chunked upload...',
                uploading: 'Uploading...',
                finalizing: 'Waiting for finalization...',
                submitted: 'Transaction submitted',
                complete: 'Complete!'
            };
            if (progressPhase) progressPhase.textContent = phaseLabels[progressData.phase] || progressData.phase;

            if (progressDetails) {
                if (progressData.chunk && progressData.totalChunks) {
                    progressDetails.textContent = `Chunk ${progressData.chunk}/${progressData.totalChunks}`;
                } else if (progressData.block) {
                    progressDetails.textContent = `Block ${progressData.block}`;
                } else {
                    progressDetails.textContent = '';
                }
            }
        }

        async function submitRuntimeUpgradeV2(forceChunked = false) {
            console.log('submitRuntimeUpgradeV2 called, forceChunked:', forceChunked);

            if (!selectedWasm) {
                runtimeLog('No WASM file selected', 'error');
                alert('Please select a WASM file first');
                return;
            }

            // Get sudo key from the runtime panel input or keys panel
            const sudoKeyInput = document.getElementById('sudoSecretKey')?.value ||
                                 document.getElementById('sudoSeed')?.value;

            if (!sudoKeyInput) {
                runtimeLog('No sudo key configured', 'error');
                alert('Please enter sudo secret key.\n\nFor dev: use alice, bob, or charlie\nFor production: paste the full 128-byte hex key');
                return;
            }

            const upgradeBtn = document.getElementById('upgradeBtn');
            const chunkedBtn = document.getElementById('chunkedBtn');

            upgradeBtn.disabled = true;
            chunkedBtn.disabled = true;
            upgradeBtn.textContent = 'SUBMITTING...';

            // Show progress bar
            const progressDiv = document.getElementById('upgradeProgress');
            if (progressDiv) progressDiv.style.display = 'block';

            try {
                // Create UpgradeManager instance
                const upgradeManager = new UpgradeManager(RPC);

                runtimeLog('Starting runtime upgrade...', 'info');
                runtimeLog(`WASM file: ${selectedWasm.name}`, 'info');
                runtimeLog(`Force chunked: ${forceChunked}`, 'info');

                const result = await upgradeManager.submitUpgrade(selectedWasm, sudoKeyInput, {
                    forceChunked,
                    onProgress: updateUpgradeProgress,
                    onLog: (msg) => runtimeLog(msg, 'info')
                });

                if (result.success) {
                    runtimeLog(`SUCCESS! Method: ${result.method}`, 'info');
                    runtimeLog(`Transaction: ${result.txHash}`, 'info');

                    upgradeBtn.textContent = 'SUCCESS!';
                    upgradeBtn.style.background = 'var(--accent-success)';

                    // Refresh status after a delay
                    setTimeout(() => {
                        updateStatus();
                        fetchNodeInfo();
                        runtimeLog('Status refreshed - check spec_version', 'info');
                    }, 6000);

                    alert(`Runtime upgrade submitted successfully!\n\nMethod: ${result.method}\nTransaction: ${result.txHash}`);
                }

            } catch (error) {
                runtimeLog(`FAILED: ${error.message}`, 'error');
                console.error('Runtime upgrade error:', error);
                upgradeBtn.textContent = 'FAILED';
                upgradeBtn.style.background = 'var(--accent-danger)';
                alert(`Runtime upgrade FAILED!\n\n${error.message}`);
            } finally {
                upgradeBtn.disabled = false;
                chunkedBtn.disabled = false;

                // Reset button style after delay
                setTimeout(() => {
                    upgradeBtn.style.background = '';
                    upgradeBtn.textContent = 'SUBMIT UPGRADE';
                }, 3000);
            }
        }

        // ============================================
        // KEYSTORE MANAGEMENT V2 - Using KeystoreManager
        // ============================================

        const keystoreManager = new KeystoreManager(RPC);

        async function checkKeystore() {
            keysLog('Checking keystore via RPC...', 'info');

            try {
                // Check pending extrinsics as a connectivity test
                const pending = await keystoreManager.getPendingExtrinsics();
                keysLog(`Node connectivity OK (${pending} pending extrinsics)`, 'info');

                // Try to generate/rotate keys to see what's in the keystore
                // This also serves as a keystore health check
                const keysResult = await keystoreManager.rotateKeys();

                const keysListBox = document.getElementById('keysListBox');
                const noKeysMsg = document.getElementById('noKeysMsg');
                const keysCount = document.getElementById('keysCount');

                if (keysResult.success && keysResult.keys) {
                    keysLog('Session keys found/generated', 'info');
                    keysLog(`Keys: ${keysResult.keys}`, 'info');

                    keysCount.textContent = '1 session key';
                    noKeysMsg.style.display = 'none';

                    // Show session key info with copy button
                    let keyInfo = document.getElementById('sessionKeyInfo');
                    if (!keyInfo) {
                        keyInfo = document.createElement('div');
                        keyInfo.id = 'sessionKeyInfo';
                        keysListBox.appendChild(keyInfo);
                    }
                    keyInfo.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <span class="info-label" style="color: var(--accent-success);">Session Keys</span>
                            <button class="btn btn-secondary btn-sm" onclick="copySessionKey()" style="padding: 2px 8px; font-size: 10px;">COPY</button>
                        </div>
                        <div style="background: var(--bg-void); padding: 8px; border-radius: 4px; word-break: break-all; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--lcars-gold);">
                            ${keysResult.keys}
                        </div>
                    `;

                    // Store for later use
                    window.lastSessionKeys = keysResult.keys;
                } else {
                    keysCount.textContent = '0 keys';
                    noKeysMsg.style.display = 'flex';
                    keysLog('No session keys - use GENERATE NEW KEY', 'warning');
                }

                keysLog('Keystore check complete', 'info');
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
            }
        }

        async function copySessionKey() {
            if (window.lastSessionKeys) {
                try {
                    await navigator.clipboard.writeText(window.lastSessionKeys);
                    keysLog('Session key copied to clipboard!', 'info');
                } catch (e) {
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = window.lastSessionKeys;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    keysLog('Session key copied to clipboard!', 'info');
                }
            } else {
                keysLog('No session key to copy', 'error');
            }
        }

        async function generateKey() {
            keysLog('Generating new session keys via RPC...', 'info');

            try {
                const result = await keystoreManager.rotateKeys();

                if (result.success) {
                    keysLog('New session keys generated!', 'info');
                    keysLog(`Keys: ${result.keys.substring(0, 40)}...`, 'info');
                    alert(`New session keys generated!\n\nKeys: ${result.keys}\n\nThese keys are now in your node's keystore.`);
                    await checkKeystore();
                } else {
                    keysLog(`Failed: ${result.message}`, 'error');
                }
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
            }
        }

        async function injectKey() {
            const seedInput = document.getElementById('sudoSeed')?.value?.trim();

            if (!seedInput) {
                keysLog('Please enter a dev seed (alice, bob, charlie)', 'error');
                return;
            }

            keysLog(`Injecting key for: ${seedInput}`, 'info');

            try {
                const devAccounts = keystoreManager.getDevAccounts();
                const seedLower = seedInput.toLowerCase();

                let publicKey, suri;
                if (seedLower === 'alice' || seedLower === '//alice') {
                    publicKey = devAccounts.alice.public;
                    suri = '//Alice';
                } else if (seedLower === 'bob' || seedLower === '//bob') {
                    publicKey = devAccounts.bob.seed || '0x' + 'b'.repeat(128);
                    suri = '//Bob';
                } else if (seedLower === 'charlie' || seedLower === '//charlie') {
                    publicKey = devAccounts.charlie.seed || '0x' + 'c'.repeat(128);
                    suri = '//Charlie';
                } else {
                    keysLog('Unknown dev account. Use alice, bob, or charlie.', 'error');
                    return;
                }

                const result = await keystoreManager.insertKey('aura', suri, publicKey);

                if (result.success) {
                    keysLog(`Key injected successfully for ${seedInput}`, 'info');
                    await checkKeystore();
                } else {
                    keysLog(`Injection failed: ${result.message}`, 'error');
                }
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
            }
        }

        // ============================================
        // GOVERNANCE V2 - Using GovernanceManager
        // ============================================

        const govManager = new GovernanceManager(RPC);

        async function refreshGovernanceStats() {
            try {
                const stats = await govManager.getStats();
                document.getElementById('activeProposals').textContent = stats.active_proposals || 0;
                document.getElementById('votingPeriod').textContent = `${stats.voting_period || 10} blocks`;

                const proposals = await govManager.getProposals();
                const proposalsList = document.getElementById('proposalsList');

                if (proposals && proposals.length > 0) {
                    proposalsList.innerHTML = proposals.map(p => `
                        <div class="info-row">
                            <span class="info-label">Proposal #${p.id}</span>
                            <span class="info-value">${p.proposed?.substring(0, 20)}... (${p.votes_for}/${p.votes_against})</span>
                        </div>
                    `).join('');
                } else {
                    proposalsList.innerHTML = '<div class="info-row"><span class="info-label">No active proposals</span></div>';
                }

                const validators = await govManager.getValidatorSet();
                document.getElementById('validatorCount').textContent = validators?.length || 0;

            } catch (error) {
                console.error('Governance stats error:', error);
            }
        }

        async function proposeValidator() {
            const validatorId = document.getElementById('proposeValidatorAccount')?.value?.trim();
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect; // Fall back to dev account name

            if (!validatorId) {
                alert('Please enter a validator account ID (32-byte hex with 0x prefix)');
                return;
            }

            govLog('Submitting validator proposal...', 'info');
            govLog(`Validator: ${validatorId.substring(0, 20)}...`, 'info');
            govLog(`Signer: ${signerSelect}`, 'info');

            try {
                const result = await govManager.proposeValidator(validatorId, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Proposal submitted! TX: ${result.txHash}`, 'info');
                    alert(`Validator proposal submitted!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Proposal failed: ${error.message}`, 'error');
                alert(`Failed to submit proposal:\n${error.message}`);
            }
        }

        // Governance console helper
        function govLog(message, type = 'info') {
            const terminal = document.getElementById('govTerminal');
            if (!terminal) return;
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearGovConsole() {
            const terminal = document.getElementById('govTerminal');
            if (terminal) terminal.innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function voteOnProposal(proposalId, approve) {
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect;

            govLog(`Voting ${approve ? 'YES' : 'NO'} on proposal #${proposalId}...`, 'info');

            try {
                const result = await govManager.vote(proposalId, approve, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Vote submitted! TX: ${result.txHash}`, 'info');
                    alert(`Vote submitted!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Vote failed: ${error.message}`, 'error');
                alert(`Failed to vote:\n${error.message}`);
            }
        }

        async function finalizeProposal(proposalId) {
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect;

            govLog(`Finalizing proposal #${proposalId}...`, 'info');

            try {
                const result = await govManager.finalizeProposal(proposalId, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Finalization submitted! TX: ${result.txHash}`, 'info');
                    alert(`Proposal finalized!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Finalization failed: ${error.message}`, 'error');
                alert(`Failed to finalize:\n${error.message}`);
            }
        }

        // Alias for UI button
        async function refreshProposals() {
            govLog('Refreshing governance data...', 'info');
            await refreshGovernanceStats();
            govLog('Refresh complete', 'info');
        }

        // Keystore source toggle
        function onKeystoreSourceChange() {
            const source = document.getElementById('keystoreSource').value;
            document.getElementById('keystorePathBox').style.display = source === 'local' ? 'block' : 'none';
            document.getElementById('hsmBox').style.display = source === 'hsm' ? 'block' : 'none';
            log(`Key storage: ${source === 'hsm' ? 'Hardware Security Module' : 'Local Keystore'}`, 'info');
        }

        // Entropy source toggle
        function onEntropySourceChange() {
            const source = document.getElementById('entropySource').value;
            log(`Entropy source: ${source}`, 'info');
        }

        // Crypto4A QRNG functions
        async function testCrypto4aRng() {
            const endpoint = document.getElementById('crypto4aEndpoint').value;
            log(`Testing Crypto4A QRNG at ${endpoint}...`, 'info');

            try {
                const res = await fetch(`${endpoint}?size=8`);
                if (res.ok) {
                    const data = await res.arrayBuffer();
                    const hex = Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('crypto4aStatus').textContent = 'Online';
                    document.getElementById('crypto4aStatus').style.color = 'var(--accent-success)';
                    document.getElementById('crypto4aEntropy').textContent = '0x' + hex;
                    log(`Crypto4A QRNG online - received: 0x${hex}`, 'info');
                } else {
                    throw new Error(`HTTP ${res.status}`);
                }
            } catch (e) {
                document.getElementById('crypto4aStatus').textContent = 'Offline';
                document.getElementById('crypto4aStatus').style.color = 'var(--accent-danger)';
                log(`Crypto4A QRNG error: ${e.message}`, 'error');
            }
        }

        async function fetchCrypto4aEntropy(bytes) {
            const endpoint = document.getElementById('crypto4aEndpoint').value;
            log(`Fetching ${bytes} bytes from Crypto4A QRNG...`, 'info');

            try {
                const res = await fetch(`${endpoint}?size=${bytes}`);
                if (res.ok) {
                    const data = await res.arrayBuffer();
                    const hex = Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('crypto4aEntropy').textContent = '0x' + hex.substring(0, 48) + (hex.length > 48 ? '...' : '');
                    log(`Received ${bytes} bytes: 0x${hex.substring(0, 32)}...`, 'info');
                } else {
                    throw new Error(`HTTP ${res.status}`);
                }
            } catch (e) {
                log(`Failed to fetch entropy: ${e.message}`, 'error');
            }
        }

        // Keys console helper
        function keysLog(message, type = 'info') {
            const terminal = document.getElementById('keysTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearKeysConsole() {
            document.getElementById('keysTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        // Clipboard helper
        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'COPIED!';
                button.style.background = 'var(--accent-success)';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 1500);
                keysLog('Public key copied to clipboard', 'info');
            } catch (e) {
                keysLog('Failed to copy: ' + e.message, 'error');
            }
        }

        // Display keys in the keys list
        function displayKeys(keys) {
            const container = document.getElementById('keysListBox');
            const countEl = document.getElementById('keysCount');
            const noKeysMsg = document.getElementById('noKeysMsg');

            countEl.textContent = `${keys.length} key${keys.length !== 1 ? 's' : ''}`;

            if (keys.length === 0) {
                noKeysMsg.style.display = 'flex';
                // Remove any existing key items
                container.querySelectorAll('.key-item').forEach(el => el.remove());
                return;
            }

            noKeysMsg.style.display = 'none';

            // Remove existing key items
            container.querySelectorAll('.key-item').forEach(el => el.remove());

            // Add each key
            keys.forEach((key, index) => {
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                keyItem.style.cssText = 'background: var(--bg-surface); border-radius: 8px; padding: 12px; margin-bottom: 12px;';

                const shortKey = key.public_key.substring(0, 24) + '...' + key.public_key.slice(-8);

                keyItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 11px;">KEY ${index + 1} - ${key.key_type || 'aura'}</span>
                        <span style="color: var(--text-muted); font-size: 10px;">${key.algorithm || 'SPHINCS+-256s'}</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <code style="flex: 1; background: var(--bg-void); padding: 8px; border-radius: 4px; font-size: 10px; color: var(--accent-success); word-break: break-all; font-family: 'JetBrains Mono', monospace;">${shortKey}</code>
                        <button class="btn btn-secondary btn-sm" onclick="copyToClipboard('${key.public_key}', this)" style="white-space: nowrap;">COPY</button>
                    </div>
                    <div style="margin-top: 8px; font-size: 10px; color: var(--text-muted);">
                        Full key saved at: <span style="color: var(--lcars-blue-light);">${key.path || 'keystore'}</span>
                    </div>
                `;

                container.appendChild(keyItem);
            });
        }

        // Legacy keys functions removed - now using KeystoreManager (defined earlier)
        // See checkKeystore(), generateKey(), injectKey() at ~lines 2061-2167

        // ===========================================
        // GOVERNANCE FUNCTIONS
        // ===========================================

        // Dev account seeds (from validator-governance-cli.py)
        const DEV_ACCOUNTS = {
            alice: '2eb5fca9ecb08243d333e38adbc99a786edea20f8f88c51b5703754eef4d7a66183e03c1de99dc133c29c5cde6a984f5',
            bob: '034a9b6570680a960ff781fec37012c355cbf698e26788b6f3b351daec75beea101f9c3b8b07fefa1d84d8b48ea02f1e',
            charlie: 'b2e5b1dd89b389f61b108bff36755bd0b5208aac741233e538a464dbd841b5bf68cc36bde662e8fde70fd41cdd605766'
        };

        // Pallet indices (from runtime)
        const VALIDATOR_GOVERNANCE_INDEX = 41;
        const VALIDATOR_REWARDS_INDEX = 40;

        function govLog(message, type = 'info') {
            const terminal = document.getElementById('govTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearGovConsole() {
            document.getElementById('govTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function proposeValidator() {
            const account = document.getElementById('proposeValidatorAccount').value.trim();
            const signer = document.getElementById('proposeSigner').value;

            if (!account || !account.startsWith('0x')) {
                govLog('Please enter a valid validator account (0x...)', 'error');
                return;
            }

            govLog(`Proposing validator: ${account.substring(0, 20)}...`, 'info');
            govLog(`Signer: ${signer}`, 'info');

            try {
                // Call custom RPC for quantum-signed extrinsic
                const callData = account.replace('0x', '');
                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '00' + callData,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    // Handle both old string format and new JSON object format
                    const txHash = result.hash || result;
                    govLog(`Proposal submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                    if (result.signer) govLog(`Signer: ${result.signer.substring(0, 20)}...`, 'info');
                    govLog('Wait for next block to see proposal in list.', 'info');
                    setTimeout(refreshProposals, 6000);
                } else {
                    govLog('Transaction failed - check node connection', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        async function refreshProposals() {
            govLog('Refreshing proposals...', 'info');

            try {
                // Query NextProposalId to get count
                // Storage: twox128("ValidatorGovernance") + twox128("NextProposalId")
                const result = await rpc('state_getStorage', ['0x' +
                    '5c41d26de442c8c2bb8a08df2fdc0ab3' + // twox128("ValidatorGovernance")
                    'f485e09e76a76c90df1caaab2dcc87f5'   // twox128("NextProposalId")
                ]);

                if (result) {
                    const nextId = parseInt(result.slice(2), 16);
                    const activeEl = document.getElementById('activeProposals');
                    if (activeEl) activeEl.textContent = nextId;
                    govLog(`Found ${nextId} proposal(s)`, 'info');

                    if (nextId > 0) {
                        displayProposals(nextId);
                    }
                } else {
                    const activeEl = document.getElementById('activeProposals');
                    if (activeEl) activeEl.textContent = '0';
                    govLog('No proposals found', 'info');
                }
            } catch (e) {
                govLog(`Error querying proposals: ${e.message}`, 'error');
            }
        }

        async function displayProposals(count) {
            const container = document.getElementById('proposalsList');
            const noMsg = document.getElementById('noProposalsMsg');

            // Clear existing proposals
            container.querySelectorAll('.proposal-item').forEach(el => el.remove());

            if (count === 0) {
                noMsg.style.display = 'flex';
                return;
            }

            noMsg.style.display = 'none';

            // Display proposal cards (simplified - would need full storage queries)
            for (let i = 0; i < count; i++) {
                const item = document.createElement('div');
                item.className = 'proposal-item';
                item.style.cssText = 'background: var(--bg-surface); border-radius: 8px; padding: 16px; margin-bottom: 12px;';

                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 14px;">PROPOSAL #${i}</span>
                        <span style="color: var(--accent-warning); font-size: 12px; padding: 4px 12px; background: rgba(255,183,77,0.1); border-radius: 20px;">ACTIVE</span>
                    </div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 16px;">
                        Proposed validator addition - Click vote to participate
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-success btn-sm" onclick="voteOnProposal(${i}, true)" style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 16px;">ðŸ‘</span> APPROVE
                        </button>
                        <button class="btn btn-danger btn-sm" onclick="voteOnProposal(${i}, false)" style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 16px;">ðŸ‘Ž</span> REJECT
                        </button>
                        <button class="btn btn-secondary btn-sm" onclick="finalizeProposal(${i})">FINALIZE</button>
                    </div>
                `;

                container.appendChild(item);
            }
        }

        async function voteOnProposal(proposalId, approve) {
            const signer = document.getElementById('proposeSigner').value;
            govLog(`Voting ${approve ? 'YES' : 'NO'} on proposal #${proposalId}...`, 'info');

            try {
                // Encode: proposal_id (u32 LE) + approve (bool)
                const idBytes = proposalId.toString(16).padStart(8, '0');
                const idLE = idBytes.match(/../g).reverse().join('');
                const approveHex = approve ? '01' : '00';

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '01' + idLE + approveHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    govLog(`Vote submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    govLog('Vote failed - are you a validator?', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        async function finalizeProposal(proposalId) {
            const signer = document.getElementById('proposeSigner').value;
            govLog(`Finalizing proposal #${proposalId}...`, 'info');

            try {
                const idBytes = proposalId.toString(16).padStart(8, '0');
                const idLE = idBytes.match(/../g).reverse().join('');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '02' + idLE,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    govLog(`Finalization submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                    setTimeout(refreshProposals, 6000);
                } else {
                    govLog('Finalization failed - voting period may not be over', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        // ===========================================
        // REWARDS FUNCTIONS
        // ===========================================

        function rewardsLog(message, type = 'info') {
            const terminal = document.getElementById('rewardsTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearRewardsConsole() {
            document.getElementById('rewardsTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function refreshRewards() {
            rewardsLog('Refreshing rewards data...', 'info');

            try {
                // First try the new RPC endpoint
                const rewardsInfo = await rpc('quantumharmony_getRewardsInfo', [
                    document.getElementById('settingsController')?.value || '0x0000000000000000000000000000000000000000'
                ]);

                if (rewardsInfo) {
                    document.getElementById('pendingRewards').textContent = rewardsInfo.pending_rewards || '0 QHM';
                    document.getElementById('totalStaked').textContent = rewardsInfo.total_staked || '0 QHM';
                    document.getElementById('certLevel').textContent = rewardsInfo.certification_level || 'Uncertified';
                    document.getElementById('rewardMultiplier').textContent = rewardsInfo.reward_multiplier || '70%';
                    rewardsLog('Rewards data refreshed', 'info');
                }
            } catch (e) {
                // Fallback to runtime version check
                try {
                    const result = await rpc('state_getRuntimeVersion');
                    if (result && result.specVersion >= 17) {
                        rewardsLog(`Runtime v${result.specVersion} - Enhanced rewards available`, 'info');
                        document.getElementById('certLevel').textContent = 'Uncertified';
                        document.getElementById('rewardMultiplier').textContent = '70%';
                    } else if (result) {
                        rewardsLog(`Runtime v${result.specVersion} - Basic rewards`, 'info');
                    }
                } catch (e2) {
                    rewardsLog(`Error: ${e2.message}`, 'error');
                }
            }
        }

        async function stakeTokens() {
            const amount = document.getElementById('stakeAmount').value;
            const signer = document.getElementById('proposeSigner')?.value || 'alice';

            if (!amount || amount <= 0) {
                rewardsLog('Please enter a valid stake amount', 'error');
                return;
            }

            rewardsLog(`Staking ${amount} QHM...`, 'warning');

            try {
                // Encode stake call: ValidatorRewards::stake(amount)
                // Pallet index 40, call index 00
                const amountBigInt = BigInt(amount) * BigInt(1_000_000_000_000); // Convert to planck
                const amountHex = amountBigInt.toString(16).padStart(32, '0');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '00' + amountHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Stake submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Stake failed - check node connection', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function requestUnstake() {
            const amount = document.getElementById('unstakeAmount').value;
            const signer = document.getElementById('proposeSigner')?.value || 'alice';

            if (!amount || amount <= 0) {
                rewardsLog('Please enter a valid unstake amount', 'error');
                return;
            }

            rewardsLog(`Requesting unstake of ${amount} QHM...`, 'warning');
            rewardsLog('100 block cooldown will apply', 'info');

            try {
                // Encode unstake call: ValidatorRewards::request_unstake(amount)
                // Pallet index 40, call index 01
                const amountBigInt = BigInt(amount) * BigInt(1_000_000_000_000);
                const amountHex = amountBigInt.toString(16).padStart(32, '0');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '01' + amountHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Unstake request submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Unstake request failed', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function claimRewards() {
            const signer = document.getElementById('proposeSigner')?.value || 'alice';
            rewardsLog('Claiming pending rewards...', 'warning');
            rewardsLog('Rate limit: 1 claim per 10 blocks', 'info');

            try {
                // Encode claim call: ValidatorRewards::claim_rewards()
                // Pallet index 40, call index 02 (no arguments)
                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '02',
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Claim submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Claim failed', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function submitUptimeProof() {
            rewardsLog('Submitting uptime proof...', 'info');
            // This would be called automatically by the node in production
            rewardsLog('Uptime proofs are submitted automatically by validator nodes', 'info');
        }

        // ===========================================
        // NETWORK MESH VISUALIZATION
        // ===========================================

        // Validator node data with geographical info
        const VALIDATOR_NODES = [
            { name: 'Alice', ip: '51.79.26.123', location: 'Montreal, Canada', provider: 'OVH', lat: 45.5, lon: -73.6, color: '#ff9966' },
            { name: 'Bob', ip: '51.79.26.168', location: 'Beauharnois, Canada', provider: 'OVH', lat: 45.3, lon: -73.9, color: '#66ccff' },
            { name: 'Charlie', ip: '209.38.225.4', location: 'Frankfurt, Germany', provider: 'DigitalOcean', lat: 50.1, lon: 8.7, color: '#99ff99' }
        ];

        let networkAnimationFrame = null;
        let nodeConnections = [];

        // Draw toroidal mesh network visualization
        function drawNetworkMesh() {
            const canvas = document.getElementById('networkCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, width, height);

            // Draw grid representing toroidal wrap-around
            ctx.strokeStyle = 'rgba(255, 153, 102, 0.1)';
            ctx.lineWidth = 1;

            // Horizontal grid lines (wrap top-bottom)
            for (let y = 0; y <= height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Vertical grid lines (wrap left-right)
            for (let x = 0; x <= width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // Calculate node positions on a torus projection
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() / 3000;

            const nodePositions = VALIDATOR_NODES.map((node, i) => {
                // Distribute nodes around the toroidal surface
                const angle = (i / VALIDATOR_NODES.length) * Math.PI * 2 + time * 0.2;
                const radius = 120 + Math.sin(time + i) * 10;
                return {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius * 0.6, // Flatten for perspective
                    node: node,
                    angle: angle
                };
            });

            // Draw connections (toroidal mesh - each node connects to all others)
            ctx.lineWidth = 2;
            nodePositions.forEach((pos1, i) => {
                nodePositions.forEach((pos2, j) => {
                    if (i >= j) return;

                    // Animated connection line
                    const gradient = ctx.createLinearGradient(pos1.x, pos1.y, pos2.x, pos2.y);
                    gradient.addColorStop(0, pos1.node.color + '80');
                    gradient.addColorStop(1, pos2.node.color + '80');
                    ctx.strokeStyle = gradient;

                    ctx.beginPath();
                    ctx.moveTo(pos1.x, pos1.y);

                    // Curved connection for visual interest
                    const midX = (pos1.x + pos2.x) / 2;
                    const midY = (pos1.y + pos2.y) / 2 - 20;
                    ctx.quadraticCurveTo(midX, midY, pos2.x, pos2.y);
                    ctx.stroke();

                    // Animated data packets along connections
                    const packetPos = (time * 2 + i * 0.5) % 1;
                    const px = pos1.x + (pos2.x - pos1.x) * packetPos;
                    const py = pos1.y + (pos2.y - pos1.y) * packetPos - Math.sin(packetPos * Math.PI) * 20;

                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            });

            // Draw wrap-around connections (toroidal property)
            ctx.strokeStyle = 'rgba(255, 153, 102, 0.3)';
            ctx.setLineDash([5, 5]);
            nodePositions.forEach(pos => {
                // Left-right wrap indicator
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x < centerX ? 0 : width, pos.y);
                ctx.stroke();

                // Top-bottom wrap indicator
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x, pos.y < centerY ? 0 : height);
                ctx.stroke();
            });
            ctx.setLineDash([]);

            // Draw nodes
            nodePositions.forEach((pos, i) => {
                // Outer glow
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 30);
                gradient.addColorStop(0, pos.node.color + '60');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
                ctx.fill();

                // Node circle
                ctx.fillStyle = pos.node.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                ctx.fill();

                // Node border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Orbitron, monospace';
                ctx.textAlign = 'center';
                ctx.fillText(pos.node.name, pos.x, pos.y + 35);

                // Location label
                ctx.fillStyle = '#888888';
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.fillText(pos.node.location.split(',')[0], pos.x, pos.y + 48);
            });

            // Title
            ctx.fillStyle = '#ff9966';
            ctx.font = '14px Orbitron, monospace';
            ctx.textAlign = 'left';
            ctx.fillText('TOROIDAL MESH', 10, 25);

            // Connection status
            ctx.fillStyle = '#66ff66';
            ctx.font = '11px JetBrains Mono, monospace';
            ctx.textAlign = 'right';
            const connectedCount = nodePositions.length;
            ctx.fillText(`${connectedCount} NODES â€¢ ${connectedCount * (connectedCount - 1) / 2} LINKS`, width - 10, 25);

            // Continue animation
            networkAnimationFrame = requestAnimationFrame(drawNetworkMesh);
        }

        // Populate validator node cards
        function updateValidatorNodes() {
            const container = document.getElementById('validatorNodes');
            if (!container) return;

            container.innerHTML = VALIDATOR_NODES.map(node => `
                <div style="background: var(--bg-surface); border-radius: var(--radius-md); padding: var(--space-3); border-left: 3px solid ${node.color};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="color: ${node.color}; font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 600;">${node.name}</span>
                        <span class="status-indicator" style="width: 8px; height: 8px; border-radius: 50%; background: var(--accent-success); box-shadow: 0 0 6px var(--accent-success);"></span>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">
                        <span style="color: var(--lcars-gold);">ðŸ“</span> ${node.location}
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">
                        <span style="color: var(--lcars-gold);">ðŸŒ</span> ${node.ip}
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary);">
                        <span style="color: var(--lcars-blue-light);">Provider:</span> ${node.provider}
                    </div>
                </div>
            `).join('');
        }

        // Fetch and display peer connections
        async function updatePeerConnections() {
            const container = document.getElementById('peersList');
            if (!container) return;

            try {
                const peers = await rpc('system_peers');
                const health = await rpc('system_health');

                if (!peers || peers.length === 0) {
                    container.innerHTML = `
                        <div class="info-row">
                            <span class="info-label" style="color: var(--accent-warning);">No direct peer connections</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label" style="font-size: 11px;">Connected peers (via health): ${health?.peers || 0}</span>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = peers.map(peer => `
                    <div class="info-row" style="padding: 8px 0; border-bottom: 1px solid var(--bg-surface);">
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <span style="color: var(--lcars-gold); font-size: 11px; font-family: 'JetBrains Mono', monospace;">
                                ${peer.peerId ? peer.peerId.substring(0, 16) + '...' : 'Unknown'}
                            </span>
                            <span style="color: var(--accent-success); font-size: 10px;">
                                ${peer.roles || 'Full'}
                            </span>
                        </div>
                        <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                            Best: #${peer.bestNumber || '?'} â€¢ Hash: ${peer.bestHash ? peer.bestHash.substring(0, 10) + '...' : '?'}
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                container.innerHTML = `
                    <div class="info-row">
                        <span class="info-label" style="color: var(--accent-danger);">Error fetching peers: ${e.message}</span>
                    </div>
                `;
            }
        }

        // Calculate and update network health
        async function updateNetworkHealth() {
            const healthEl = document.getElementById('networkHealth');
            const finalizedEl = document.getElementById('networkFinalized');
            if (!healthEl) return;

            try {
                const health = await rpc('system_health');
                const finalizedHash = await rpc('chain_getFinalizedHead');

                if (!health) {
                    healthEl.textContent = 'OFFLINE';
                    healthEl.style.color = 'var(--accent-danger)';
                    return;
                }

                // Calculate health score based on peers and sync status
                const peerCount = health.peers || 0;
                const isSyncing = health.isSyncing;

                let healthStatus = 'CRITICAL';
                let healthColor = 'var(--accent-danger)';

                if (peerCount >= 2 && !isSyncing) {
                    healthStatus = 'OPTIMAL';
                    healthColor = 'var(--accent-success)';
                } else if (peerCount >= 1) {
                    healthStatus = 'DEGRADED';
                    healthColor = 'var(--accent-warning)';
                } else if (isSyncing) {
                    healthStatus = 'SYNCING';
                    healthColor = 'var(--lcars-blue-light)';
                }

                healthEl.textContent = healthStatus;
                healthEl.style.color = healthColor;

                // Update finalized block
                if (finalizedHash && finalizedEl) {
                    const finalizedHeader = await rpc('chain_getHeader', [finalizedHash]);
                    if (finalizedHeader?.number) {
                        const blockNum = parseInt(finalizedHeader.number, 16);
                        finalizedEl.textContent = blockNum.toLocaleString();
                    }
                }
            } catch (e) {
                healthEl.textContent = 'ERROR';
                healthEl.style.color = 'var(--accent-danger)';
            }
        }

        // Initialize network panel
        function initNetworkPanel() {
            updateValidatorNodes();
            drawNetworkMesh();
            updatePeerConnections();
            updateNetworkHealth();

            // Update peer connections and health every 10 seconds
            setInterval(() => {
                updatePeerConnections();
                updateNetworkHealth();
            }, 10000);
        }

        // Quantum Status
        async function updateQuantumStatus() {
            try {
                const res = await fetch(config.qkd + '/health');
                document.getElementById('qkdStatus').classList.toggle('offline', !res.ok);
                document.getElementById('qkdStatusText').textContent = res.ok ? 'Online' : 'Offline';
            } catch {
                document.getElementById('qkdStatus').classList.add('offline');
                document.getElementById('qkdStatusText').textContent = 'Offline';
            }

            try {
                const res = await fetch(config.hub + '/api/health');
                document.getElementById('hubStatus').classList.toggle('offline', !res.ok);
                document.getElementById('hubStatusText').textContent = res.ok ? 'Online' : 'Offline';
                if (res.ok) {
                    const health = await res.json();
                    if (health.sources) {
                        document.getElementById('hubSources').textContent = health.sources.filter(s => s.healthy).length + '/' + health.sources.length;
                    }
                }
            } catch {
                document.getElementById('hubStatus').classList.add('offline');
                document.getElementById('hubStatusText').textContent = 'Offline';
            }
        }

        // Settings
        function saveSettings() {
            config.rpc = document.getElementById('settingsRpc').value;
            config.qkd = document.getElementById('settingsQkd').value;
            config.hub = document.getElementById('settingsHub').value;
            config.controller = document.getElementById('settingsController').value;
            Object.entries(config).forEach(([k, v]) => localStorage.setItem(k, v));
            log('Settings saved', 'info');
            updateStatus();
        }

        function loadSettings() {
            document.getElementById('settingsRpc').value = config.rpc;
            document.getElementById('settingsQkd').value = config.qkd;
            document.getElementById('settingsHub').value = config.hub;
            document.getElementById('settingsController').value = config.controller;
        }

        // Init
        async function init() {
            console.log('init() starting');
            try {
                loadSettings();
                loadAvatar();
                updateAgentModeUI();
            } catch(e) {
                console.error('init setup error:', e);
            }
            log('Connecting to ' + RPC, 'info');

            console.log('Calling fetchAllData...');
            // Fetch all data immediately
            await fetchAllData();
            console.log('fetchAllData complete');

            // Initialize network panel with toroidal mesh visualization
            initNetworkPanel();

            // Initialize governance panel
            refreshProposals();

            // Initialize rewards panel
            refreshRewards();

            // Check quantum status
            updateQuantumStatus();

            // Update every 5 seconds
            setInterval(fetchAllData, 5000);
            setInterval(updateQuantumStatus, 15000);
            setInterval(checkAutoStake, 30000);

            // Refresh governance every 30 seconds
            setInterval(refreshProposals, 30000);

            log('Dashboard initialized - all panels active', 'info');
        }

        // Single function to fetch all node data
        async function fetchAllData() {
            console.log('fetchAllData called');
            try {
                // 1. Health check
                console.log('Calling system_health...');
                const health = await rpc('system_health');
                console.log('Health result:', health);

                const $ = id => document.getElementById(id);

                if (!health) {
                    console.log('No health - marking offline');
                    $('nodeProcessStatus')?.classList.add('offline');
                    $('nodeProcessText') && ($('nodeProcessText').textContent = 'Offline');
                    $('statusDot')?.classList.remove('connected');
                    return;
                }

                console.log('Setting UI with health data');
                $('nodeProcessStatus')?.classList.remove('offline');
                $('nodeProcessText') && ($('nodeProcessText').textContent = 'Running');
                $('statusDot')?.classList.add('connected');
                $('peerCount') && ($('peerCount').textContent = health.peers);
                $('networkPeers') && ($('networkPeers').textContent = health.peers);
                $('syncStatus') && ($('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced');

                // 2. Block height
                const header = await rpc('chain_getHeader');
                if (header?.number) {
                    const blockNum = parseInt(header.number, 16);
                    $('blockHeight') && ($('blockHeight').textContent = blockNum.toLocaleString());
                    $('networkBest') && ($('networkBest').textContent = blockNum.toLocaleString());
                }

                // 3. Node info
                const chain = await rpc('system_chain');
                if (chain) $('chainName') && ($('chainName').textContent = chain);

                const name = await rpc('system_name');
                if (name) $('nodeName') && ($('nodeName').textContent = name);

                const version = await rpc('system_version');
                if (version) $('nodeVersion') && ($('nodeVersion').textContent = version);

                const runtime = await rpc('state_getRuntimeVersion');
                if (runtime?.specVersion) {
                    $('runtimeVersion') && ($('runtimeVersion').textContent = 'v' + runtime.specVersion);
                }

                $('rpcEndpoint') && ($('rpcEndpoint').textContent = RPC);

                // 4. Recent blocks
                await loadRecentBlocks();

                connected = true;
                $('footerStatus') && ($('footerStatus').textContent = 'Connected');

            } catch (e) {
                console.error('fetchAllData error:', e);
            }
        }

        // Load recent blocks with author info
        async function loadRecentBlocks() {
            const container = document.getElementById('recentBlocksContainer');
            const header = await rpc('chain_getHeader');
            if (!header) return;

            const currentBlock = parseInt(header.number, 16);
            let html = '';

            // Map known validator public keys to names
            const validatorNames = {
                '0x24a5': 'Alice',
                '0xb8e0': 'Bob',
                '0x8c': 'Charlie'
            };

            for (let i = 0; i < 5; i++) {
                const blockNum = currentBlock - i;
                const hash = await rpc('chain_getBlockHash', [blockNum]);
                if (!hash) continue;

                const block = await rpc('chain_getBlock', [hash]);
                const extCount = block?.block?.extrinsics?.length || 0;

                // Try to identify block author from Aura
                let authorLabel = '';
                const authorIndex = blockNum % 2; // Aura round-robin with 2 authorities
                const authorColors = ['#ff9966', '#66ccff', '#99ff99'];
                const authorName = ['Alice', 'Bob', 'Charlie'][authorIndex] || '?';
                authorLabel = `<span style="color:${authorColors[authorIndex]};font-size:10px;margin-left:8px;">by ${authorName}</span>`;

                html += `<div class="info-row" style="padding:8px 0;border-bottom:1px solid var(--bg-surface);">
                    <div style="display:flex;justify-content:space-between;width:100%">
                        <span style="color:var(--lcars-gold);font-family:'Orbitron',monospace;font-size:13px">#${blockNum.toLocaleString()}${authorLabel}</span>
                        <span style="color:var(--accent-success);font-size:12px">${extCount} ext</span>
                    </div>
                    <div style="width:100%;margin-top:4px">
                        <span style="color:var(--text-muted);font-size:10px;font-family:'JetBrains Mono',monospace">${hash.slice(0,10)}...${hash.slice(-6)}</span>
                    </div>
                </div>`;
            }

            container.innerHTML = html || '<div class="info-row"><span class="info-label">No blocks</span></div>';
        }

        // Query current validators (authorities)
        async function queryValidators() {
            try {
                // Query Aura authorities
                const authorities = await rpc('state_call', ['AuraApi_authorities', '0x']);
                if (authorities) {
                    log(`Aura authorities: ${authorities.substring(0, 40)}...`, 'info');
                }
                return authorities;
            } catch (e) {
                console.error('Failed to query validators:', e);
                return null;
            }
        }

        // =========================================
        // QCAD STABLECOIN PEG FUNCTIONS
        // =========================================
        let qcadPriceHistory = [];
        let qcadChart = null;

        async function refreshQcadData() {
            log('Fetching QCAD oracle data...', 'info');
            try {
                // Try to get CAD/USD rate from Bank of Canada or fallback
                const rate = await fetchCadUsdRate();
                if (rate) {
                    document.getElementById('cadUsdRate').textContent = rate.toFixed(4);
                    document.getElementById('currentCadUsd').textContent = `$${rate.toFixed(4)} USD`;
                    document.getElementById('oracleStatus').textContent = 'Active';
                    document.getElementById('oracleStatus').style.color = 'var(--accent-success)';
                    document.getElementById('oracleLastUpdate').textContent = new Date().toLocaleTimeString();

                    // Add to history
                    qcadPriceHistory.push({ time: Date.now(), rate: rate });
                    if (qcadPriceHistory.length > 100) qcadPriceHistory.shift();

                    drawQcadChart();
                    log(`CAD/USD rate updated: ${rate.toFixed(4)}`, 'success');
                }
            } catch (e) {
                log('Failed to fetch QCAD data: ' + e.message, 'error');
                document.getElementById('oracleStatus').textContent = 'Error';
                document.getElementById('oracleStatus').style.color = 'var(--accent-danger)';
            }
        }

        async function fetchCadUsdRate() {
            // Try multiple sources
            try {
                // Primary: Use a public forex API
                const response = await fetch('https://api.exchangerate-api.com/v4/latest/CAD');
                const data = await response.json();
                if (data && data.rates && data.rates.USD) {
                    return data.rates.USD;
                }
            } catch (e) {
                console.log('Primary API failed, using fallback');
            }

            // Fallback: approximate rate
            return 0.7350; // Approximate CAD/USD rate
        }

        function drawQcadChart() {
            const canvas = document.getElementById('qcadPriceChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#14141a';
            ctx.fillRect(0, 0, width, height);

            if (qcadPriceHistory.length < 2) {
                ctx.fillStyle = '#707080';
                ctx.font = '14px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting price data...', width/2, height/2);
                return;
            }

            // Draw grid
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Find min/max
            const rates = qcadPriceHistory.map(p => p.rate);
            const min = Math.min(...rates) * 0.999;
            const max = Math.max(...rates) * 1.001;
            const range = max - min || 0.01;

            // Draw line
            ctx.strokeStyle = '#f8a100';
            ctx.lineWidth = 2;
            ctx.beginPath();

            qcadPriceHistory.forEach((point, i) => {
                const x = (i / (qcadPriceHistory.length - 1)) * width;
                const y = height - ((point.rate - min) / range) * height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw current value
            const lastRate = qcadPriceHistory[qcadPriceHistory.length - 1].rate;
            ctx.fillStyle = '#f8a100';
            ctx.font = 'bold 16px Rajdhani';
            ctx.textAlign = 'right';
            ctx.fillText(`$${lastRate.toFixed(4)}`, width - 10, 25);
        }

        function viewOracleHistory() {
            log('Oracle history: ' + qcadPriceHistory.length + ' data points', 'info');
            if (qcadPriceHistory.length > 0) {
                const avg = qcadPriceHistory.reduce((a, b) => a + b.rate, 0) / qcadPriceHistory.length;
                log(`Average CAD/USD: ${avg.toFixed(4)}`, 'info');
            }
        }

        // Auto-refresh QCAD data every 60 seconds
        setInterval(() => {
            if (document.getElementById('panel-qcad')?.classList.contains('active')) {
                refreshQcadData();
            }
        }, 60000);

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
