<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumHarmony Node Operator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Rajdhani:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        /* ===========================================
           DESIGN SYSTEM - Based on 8px Grid
           Color Palette: 60/30/10 Rule
           =========================================== */
        :root {
            /* 60% - Background Colors */
            --bg-void: #000000;
            --bg-primary: #0c0c10;
            --bg-elevated: #14141a;
            --bg-surface: #1c1c24;

            /* 30% - Structural Colors (LCARS) */
            --lcars-gold: #f8a100;
            --lcars-gold-light: #ffc044;
            --lcars-gold-dark: #cc8400;
            --lcars-blue: #5c88da;
            --lcars-blue-light: #88aaff;

            /* 10% - Accent Colors */
            --accent-success: #22c997;
            --accent-danger: #ef5350;
            --accent-warning: #ffb74d;

            /* Text Colors - High Contrast */
            --text-primary: #ffffff;
            --text-secondary: #b0b0c0;
            --text-muted: #707080;
            --text-on-color: #0c0c10;

            /* Spacing Scale (8px base) */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 16px;
            --space-4: 24px;
            --space-5: 32px;
            --space-6: 48px;

            /* Typography Scale */
            --text-xs: 10px;
            --text-sm: 12px;
            --text-base: 14px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;

            /* Radii - LCARS characteristic */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-pill: 100px;
            --radius-lcars: 40px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            color: var(--text-primary);
            font-family: 'Rajdhani', system-ui, sans-serif;
            font-weight: 500;
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ===========================================
           LCARS FRAME STRUCTURE
           =========================================== */
        .lcars-frame {
            display: grid;
            grid-template-columns: 200px 1fr;
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            gap: 3px;
            padding: var(--space-2);
        }

        /* Header Bar */
        .lcars-header {
            grid-column: 1 / -1;
            display: flex;
            height: 72px;
        }

        .header-cap {
            width: 200px;
            background: var(--lcars-gold);
            border-radius: var(--radius-lcars) 0 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-3);
        }

        .header-cap img {
            height: 48px;
            width: auto;
            filter: brightness(0);
        }

        .header-bar {
            flex: 1;
            background: var(--lcars-gold);
            display: flex;
            align-items: center;
            padding: 0 var(--space-5);
        }

        .header-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--text-on-color);
            letter-spacing: 3px;
        }

        .header-end {
            width: 100px;
            background: var(--lcars-blue);
            border-radius: 0 var(--radius-lcars) 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-danger);
            box-shadow: 0 0 12px var(--accent-danger);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: var(--accent-success);
            box-shadow: 0 0 12px var(--accent-success);
        }

        /* Sidebar Navigation */
        .lcars-sidebar {
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            padding: var(--space-3) 0;
            border-radius: 0 0 0 var(--radius-lcars);
        }

        .sidebar-accent {
            height: 24px;
            background: var(--lcars-gold);
            margin: 0 var(--space-2) var(--space-4) var(--space-2);
            border-radius: var(--radius-pill);
        }

        .nav-btn {
            background: var(--lcars-gold-dark);
            border: none;
            color: var(--text-on-color);
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            font-weight: 600;
            padding: var(--space-3) var(--space-3);
            margin: 2px var(--space-2) 2px 0;
            border-radius: 0 var(--radius-pill) var(--radius-pill) 0;
            cursor: pointer;
            text-align: left;
            transition: background 0.15s ease;
            letter-spacing: 1px;
        }

        .nav-btn:hover {
            background: var(--lcars-gold);
        }

        .nav-btn.active {
            background: var(--accent-success);
        }

        .nav-spacer {
            flex: 1;
        }

        /* Main Content Area */
        .lcars-main {
            background: var(--bg-primary);
            border-radius: 0 0 var(--radius-lcars) 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-header {
            background: var(--lcars-gold);
            padding: var(--space-2) var(--space-4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-label {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--text-on-color);
            letter-spacing: 1px;
        }

        .content-area {
            flex: 1;
            padding: var(--space-4);
            overflow-y: auto;
        }

        /* Footer Bar */
        .lcars-footer {
            grid-column: 1 / -1;
            display: flex;
            height: 48px;
        }

        .footer-cap {
            width: 200px;
            background: var(--lcars-gold);
            border-radius: 0 0 0 var(--radius-lcars);
        }

        .footer-bar {
            flex: 1;
            background: var(--lcars-gold-dark);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--space-4);
        }

        .footer-text {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--text-on-color);
            letter-spacing: 1px;
        }

        .footer-end {
            width: 100px;
            background: var(--lcars-blue);
            border-radius: 0 0 var(--radius-lcars) 0;
        }

        /* ===========================================
           CONTENT COMPONENTS
           =========================================== */

        /* Panels */
        .panel { display: none; }
        .panel.active { display: block; }

        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--lcars-gold);
            padding-bottom: var(--space-2);
            margin-bottom: var(--space-4);
            border-bottom: 2px solid var(--lcars-gold-dark);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .stat-card {
            background: var(--bg-elevated);
            border-left: 4px solid var(--lcars-gold);
            padding: var(--space-3);
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
        }

        .stat-label {
            font-size: var(--text-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-1);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-value.blue { color: var(--lcars-blue-light); }
        .stat-value.green { color: var(--accent-success); }
        .stat-value.gold { color: var(--lcars-gold-light); }

        /* Section Title */
        .section-title {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin: var(--space-4) 0 var(--space-3) 0;
            padding-bottom: var(--space-2);
            border-bottom: 1px solid var(--bg-surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Buttons */
        .btn {
            font-family: 'Orbitron', monospace;
            font-size: var(--text-sm);
            font-weight: 600;
            padding: var(--space-2) var(--space-4);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: var(--lcars-gold);
            color: var(--text-on-color);
        }
        .btn-primary:hover { background: var(--lcars-gold-light); }

        .btn-success {
            background: var(--accent-success);
            color: var(--text-on-color);
        }
        .btn-success:hover { opacity: 0.9; }

        .btn-danger {
            background: var(--accent-danger);
            color: var(--text-primary);
        }
        .btn-danger:hover { opacity: 0.9; }

        .btn-secondary {
            background: var(--lcars-blue);
            color: var(--text-on-color);
        }
        .btn-secondary:hover { background: var(--lcars-blue-light); }

        .btn-sm {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
            flex-wrap: wrap;
            align-items: center;
        }

        /* Status Pill */
        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: var(--bg-elevated);
            border: 1px solid var(--accent-success);
            border-radius: var(--radius-pill);
            margin-left: auto;
        }

        .status-pill .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-success);
            animation: pulse 2s infinite;
        }

        .status-pill.offline {
            border-color: var(--accent-danger);
        }

        .status-pill.offline .dot {
            background: var(--accent-danger);
        }

        .status-pill-text {
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Info Box */
        .info-box {
            background: var(--bg-elevated);
            border: 1px solid var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-3);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--bg-surface);
            flex-wrap: wrap;
        }

        .info-row:last-child { border-bottom: none; }

        /* Recent block entry styling */
        .recent-block-entry {
            padding: 10px 0;
            border-bottom: 1px solid var(--bg-surface);
        }
        .recent-block-entry:last-child { border-bottom: none; }

        .info-label {
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        .info-value {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: var(--text-sm);
        }

        /* Terminal */
        .terminal {
            background: var(--bg-void);
            border: 1px solid var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            font-family: 'JetBrains Mono', monospace;
            font-size: var(--text-sm);
            color: var(--accent-success);
            max-height: 280px;
            overflow-y: auto;
        }

        .terminal-line {
            margin: var(--space-1) 0;
            line-height: 1.4;
        }

        .terminal-line.error { color: var(--accent-danger); }
        .terminal-line.warning { color: var(--accent-warning); }
        .terminal-line.info { color: var(--lcars-blue-light); }

        /* Forms */
        .form-group {
            margin-bottom: var(--space-3);
        }

        .form-label {
            display: block;
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-bottom: var(--space-1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-elevated);
            border: 2px solid var(--bg-surface);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: var(--text-base);
            transition: border-color 0.15s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--lcars-gold);
        }

        /* File Drop */
        .file-drop {
            border: 2px dashed var(--bg-surface);
            border-radius: var(--radius-md);
            padding: var(--space-6);
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .file-drop:hover, .file-drop.dragover {
            border-color: var(--lcars-gold);
            background: rgba(248, 161, 0, 0.05);
        }

        .file-drop-icon {
            font-size: 48px;
            margin-bottom: var(--space-3);
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-4);
        }

        /* User Menu & Avatar Styles */
        .user-menu, .avatar-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--lcars-gold-dark);
            border-radius: var(--radius-md);
            min-width: 200px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .user-menu {
            left: 0;
            right: auto;
            margin-top: 8px;
        }

        .avatar-menu {
            margin-top: 8px;
        }

        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            transition: background 0.15s ease;
        }

        .menu-item:hover {
            background: var(--bg-surface);
            color: var(--text-primary);
        }

        .menu-divider {
            height: 1px;
            background: var(--bg-surface);
            margin: 4px 0;
        }

        .avatar-container {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .avatar-placeholder {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--lcars-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-family: 'Orbitron', monospace;
            transition: all 0.2s ease;
        }

        .avatar-placeholder:hover {
            border-color: var(--lcars-gold-light);
            transform: scale(1.05);
        }

        .avatar-placeholder img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Human Intervention Required Badge */
        .human-required {
            background: var(--accent-danger);
            color: white;
            padding: 2px 8px;
            border-radius: var(--radius-pill);
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive */
        @media (max-width: 900px) {
            .grid-2 { grid-template-columns: 1fr; }
            .lcars-frame { grid-template-columns: 140px 1fr; }
            .header-cap, .footer-cap { width: 140px; }
        }
    </style>
    <!-- Polkadot.js API for runtime upgrades -->
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/util@12.6.2/bundle-polkadot-util.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@12.6.2/bundle-polkadot-util-crypto.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/keyring@12.6.2/bundle-polkadot-keyring.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@polkadot/api@10.13.1/bundle-polkadot-api.min.js"></script>
    <!-- QuantumHarmony Manager Modules -->
    <script src="js/upgrade-manager.js"></script>
    <script src="js/keystore-manager.js"></script>
    <script src="js/governance-manager.js"></script>
</head>
<body>
    <div class="lcars-frame">
        <!-- Header -->
        <div class="lcars-header">
            <div class="header-cap">
                <img src="logo.png" alt="Paraxiom">
            </div>
            <div class="header-bar">
                <span class="header-title">Node Operator</span>
                <div id="accountBadge" class="account-badge" onclick="copyMyAddress()" title="Click to copy address for faucet" style="display: none; margin-left: 16px; padding: 4px 12px; background: var(--bg-surface); border-radius: 4px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--lcars-gold); border: 1px solid var(--lcars-gold-dim);">
                    <span id="accountBadgeAddress">No Account</span>
                    <span style="margin-left: 8px; font-size: 9px; color: var(--text-muted);">ðŸ“‹ COPY</span>
                </div>
                <div class="header-menu" onclick="toggleUserMenu()" style="margin-left: 16px; cursor: pointer; padding: 4px 8px;">
                </div>
                <!-- User Menu Dropdown -->
                <div id="userMenu" class="user-menu" style="display: none;">
                    <div class="menu-item" onclick="showPanel('settings'); closeUserMenu();">Profile Settings</div>
                    <div class="menu-item" onclick="toggleAgentMode()">
                        <span>Agent Mode</span>
                        <span id="agentModeStatus" style="margin-left: auto; font-size: 10px; color: var(--accent-danger);">OFF</span>
                    </div>
                    <div class="menu-item" onclick="showPanel('keys'); closeUserMenu();">Manage Keys</div>
                    <div class="menu-divider"></div>
                    <div class="menu-item" style="color: var(--accent-warning);" onclick="closeUserMenu();">Disconnect</div>
                </div>
            </div>
            <div class="header-end" style="cursor: pointer; position: relative;" onclick="toggleAvatarMenu()">
                <div class="avatar-container" id="avatarContainer">
                    <div class="avatar-placeholder" id="avatarPlaceholder">
                        <span style="font-size: 18px;">?</span>
                    </div>
                </div>
                <!-- Avatar Menu -->
                <div id="avatarMenu" class="avatar-menu" style="display: none;">
                    <div style="padding: 12px; border-bottom: 1px solid var(--bg-surface);">
                        <div style="font-weight: 600; color: var(--text-primary);" id="operatorName">Anonymous Operator</div>
                        <div style="font-size: 10px; color: var(--text-muted);" id="operatorAddress">Not connected</div>
                    </div>
                    <div class="menu-item" onclick="uploadAvatar()">Upload Avatar</div>
                    <div class="menu-item" onclick="showPanel('settings'); closeAvatarMenu();">Account Settings</div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="lcars-sidebar">
            <div class="sidebar-accent"></div>
            <button class="nav-btn active" onclick="showPanel('status')">STATUS</button>
            <button class="nav-btn" onclick="showPanel('transfer')">TRANSFER</button>
            <button class="nav-btn" onclick="showPanel('faucet')">FAUCET</button>
            <button class="nav-btn" onclick="showPanel('governance')">GOVERN</button>
            <button class="nav-btn" onclick="showPanel('rewards')">REWARDS</button>
            <button class="nav-btn" onclick="showPanel('runtime')">RUNTIME</button>
            <button class="nav-btn" onclick="showPanel('keys')">KEYS</button>
            <button class="nav-btn" onclick="showPanel('quantum')">QUANTUM</button>
            <button class="nav-btn" onclick="showPanel('network')">NETWORK</button>
            <button class="nav-btn" onclick="showPanel('reporter')">REPORTER</button>
            <button class="nav-btn" onclick="showPanel('messages')">MESSAGES</button>
            <div class="nav-spacer"></div>
            <button class="nav-btn" onclick="showPanel('settings')">SETTINGS</button>
            <button class="nav-btn" onclick="showPanel('proofs')">PROOFS</button>
        </div>

        <!-- Main Content -->
        <div class="lcars-main">
            <div class="content-header">
                <span class="content-label">SYSTEM INTERFACE v1.0</span>
                <span class="content-label" id="timestamp">---</span>
            </div>
            <div class="content-area">

                <!-- STATUS PANEL -->
                <div id="panel-status" class="panel active">
                    <h2 class="panel-title">Node Status</h2>

                    <div class="control-bar">
                        <button class="btn btn-success" onclick="startNode()" id="startBtn">START</button>
                        <button class="btn btn-danger" onclick="stopNode()" id="stopBtn">STOP</button>
                        <button class="btn btn-primary" onclick="restartNode()" id="restartBtn">RESTART</button>
                        <div class="status-pill" id="nodeProcessStatus">
                            <div class="dot"></div>
                            <span class="status-pill-text" id="nodeProcessText">Unknown</span>
                        </div>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Block Height</div>
                            <div class="stat-value" id="blockHeight">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Connected Peers</div>
                            <div class="stat-value blue" id="peerCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Runtime</div>
                            <div class="stat-value green" id="runtimeVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Sync Status</div>
                            <div class="stat-value gold" id="syncStatus">---</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Node Information</span>
                        <button class="btn btn-secondary btn-sm" onclick="debugRPC()">DEBUG</button>
                        <button class="btn btn-secondary btn-sm" onclick="fetchNodeInfo()">REFRESH</button>
                    </div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Chain</span>
                            <span class="info-value" id="chainName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Node Name</span>
                            <span class="info-value" id="nodeName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Version</span>
                            <span class="info-value" id="nodeVersion">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">RPC Endpoint</span>
                            <span class="info-value" id="rpcEndpoint">---</span>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Recent Blocks</span>
                        <button class="btn btn-secondary btn-sm" onclick="refreshRecentBlocks()">REFRESH</button>
                    </div>
                    <div class="info-box" id="recentBlocksContainer" style="max-height: 200px; overflow-y: auto;">
                        <div class="recent-block" id="noBlocksMsg">
                            <span class="info-label">Loading recent blocks...</span>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearTerminal()">CLEAR</button>
                    </div>
                    <div class="terminal" id="terminal">
                        <div class="terminal-line info">System initialized</div>
                    </div>
                </div>

                <!-- TRANSFER PANEL -->
                <div id="panel-transfer" class="panel">
                    <h2 class="panel-title">Transfer Funds</h2>

                    <!-- Validator Account Warning -->
                    <div id="devAccountWarning" style="display: none; margin-bottom: 16px; padding: 12px; background: rgba(255, 183, 77, 0.1); border-left: 3px solid var(--accent-warning); border-radius: 4px;">
                        <div style="color: var(--accent-warning); font-weight: 600; margin-bottom: 4px;">Account Not Funded</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">
                            This validator account shows 0 balance.
                            Use the <strong>FAUCET</strong> tab to request tokens for your own address.
                        </div>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Your Balance</div>
                            <div class="stat-value gold" id="senderBalance">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Key Status</div>
                            <div class="stat-value blue" id="keyStatus">No Key</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Signature</div>
                            <div class="stat-value">SPHINCS+</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Network Fee</div>
                            <div class="stat-value green">~0.001 QMHY</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Send QMHY Tokens</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Your Secret Key</label>
                            <input type="password" class="form-input" id="transferSecretKey" placeholder="Paste 48-byte seed (hex) or 128-byte secret key" onchange="updateSenderFromKey()">
                            <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                Your key is used locally to sign transactions. Never share it.
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Your Address (derived from key)</label>
                            <input type="text" class="form-input" id="transferSenderAddress" placeholder="Will be derived from secret key" readonly style="background: var(--bg-void);">
                        </div>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Recipient Address</label>
                            <input type="text" class="form-input" id="transferRecipient" placeholder="5CT4mnE7KMeGG6MqSyVLFa7CLkyRtb8FHCafW4zUHKYh4cg6">
                        </div>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Amount (QMHY)</label>
                            <input type="number" class="form-input" id="transferAmount" placeholder="100" step="0.001" min="0">
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-success" onclick="sendTransfer()">SEND TRANSFER</button>
                            <button class="btn btn-secondary" onclick="updateSenderBalance()">CHECK BALANCE</button>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Quick Fill Recipient</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-primary btn-sm" onclick="fillRecipient('alice')">Alice</button>
                            <button class="btn btn-primary btn-sm" onclick="fillRecipient('bob')">Bob</button>
                            <button class="btn btn-primary btn-sm" onclick="fillRecipient('charlie')">Charlie</button>
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                            Quick fill with validator addresses for testing
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Transfer Console</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearTransferConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="transferTerminal">
                        <div class="terminal-line info">Transfer panel initialized</div>
                    </div>
                </div>

                <!-- FAUCET PANEL -->
                <div id="panel-faucet" class="panel">
                    <h2 class="panel-title">Testnet Faucet</h2>

                    <!-- Faucet Service Status -->
                    <div class="info-box" style="margin-bottom: 24px; border-left: 3px solid var(--lcars-gold);">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                            <div class="status-pill" id="faucetServiceStatus">
                                <div class="dot"></div>
                                <span class="status-pill-text" id="faucetServiceStatusText">Checking...</span>
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="checkFaucetService()">CHECK</button>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Faucet Service</span>
                            <span class="info-value" style="font-size: 11px;">Proxied via /faucet (â†’ 51.79.26.123)</span>
                        </div>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Drip Amount</div>
                            <div class="stat-value gold">100 QMHY</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Rate Limit</div>
                            <div class="stat-value">60 seconds</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Service Status</div>
                            <div class="stat-value" id="faucetServiceHealth">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Drips</div>
                            <div class="stat-value blue" id="totalDrips">0</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Request Testnet Tokens</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Recipient Address (SS58)</label>
                            <input type="text" class="form-input" id="faucetRecipient" placeholder="5CT4mnE7KMeGG6MqSyVLFa7CLkyRtb8FHCafW4zUHKYh4cg6">
                        </div>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <button class="btn btn-success" id="requestDripBtn" onclick="requestDrip()">REQUEST 100 QMHY</button>
                            <button class="btn btn-secondary" onclick="checkFaucetService()">CHECK SERVICE</button>
                        </div>
                        <div id="faucetOfflineWarning" style="display: none; margin-top: 12px; padding: 8px; background: rgba(239, 83, 80, 0.1); border-radius: 4px; font-size: 12px; color: var(--accent-danger);">
                            Faucet service is offline. Please try again later or contact the network operator.
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Generate New Account</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <p style="color: var(--text-secondary); margin-bottom: 12px; font-size: 13px;">
                            Generate a new SPHINCS+ keypair. Save the seed securely - it cannot be recovered!
                        </p>
                        <button class="btn btn-primary" onclick="generateAccount()">GENERATE SPHINCS+ ACCOUNT</button>
                        <div id="generatedAccount" style="margin-top: 12px;"></div>
                    </div>

                    <div class="section-title">
                        <span>Faucet Console</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearFaucetConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="faucetTerminal">
                        <div class="terminal-line info">Faucet panel initialized</div>
                        <div class="terminal-line info">Faucet proxied via /faucet â†’ 51.79.26.123</div>
                    </div>
                </div>

                <!-- GOVERNANCE PANEL -->
                <div id="panel-governance" class="panel">
                    <h2 class="panel-title">Validator Governance</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Active Proposals</div>
                            <div class="stat-value gold" id="activeProposals">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Validators</div>
                            <div class="stat-value" id="validatorCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Voting Period</div>
                            <div class="stat-value blue" id="votingPeriod">10 blocks</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Min Votes Required</div>
                            <div class="stat-value green" id="minVotes">1</div>
                        </div>
                    </div>

                    <div class="section-title">
                        <span>Propose New Validator</span>
                    </div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Validator Account (Public Key)</label>
                            <input type="text" class="form-input" id="proposeValidatorAccount" placeholder="0x...">
                        </div>
                        <div class="form-group" style="margin-bottom: 12px;">
                            <label class="form-label">Sign As</label>
                            <select class="form-input" id="proposeSigner">
                                <option value="alice">Alice (Montreal)</option>
                                <option value="bob">Bob (Beauharnois)</option>
                                <option value="charlie">Charlie (Frankfurt)</option>
                            </select>
                        </div>
                        <button class="btn btn-success" onclick="proposeValidator()">SUBMIT PROPOSAL</button>
                    </div>

                    <div class="section-title">
                        <span>Active Proposals</span>
                        <button class="btn btn-secondary btn-sm" onclick="refreshProposals()">REFRESH</button>
                    </div>
                    <div id="proposalsList" class="info-box">
                        <div class="info-row" id="noProposalsMsg">
                            <span class="info-label">No active proposals. Click REFRESH to check.</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearGovConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="govTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Governance console ready</div>
                    </div>
                </div>

                <!-- REWARDS PANEL -->
                <div id="panel-rewards" class="panel">
                    <h2 class="panel-title">Validator Rewards</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Pending Rewards</div>
                            <div class="stat-value gold" id="pendingRewards">0 QMHY</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Staked</div>
                            <div class="stat-value blue" id="totalStaked">0 QMHY</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Certification</div>
                            <div class="stat-value" id="certLevel">Uncertified</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Reward Multiplier</div>
                            <div class="stat-value green" id="rewardMultiplier">70%</div>
                        </div>
                    </div>

                    <div class="section-title">Certification Levels</div>
                    <div class="grid-2" style="margin-bottom: 24px;">
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--text-muted);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Uncertified</span>
                                <span style="color: var(--accent-warning); margin-left: auto;">70% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Default level for new validators. Limited reward multiplier until verification.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--lcars-blue);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">KYC Verified</span>
                                <span style="color: var(--accent-success); margin-left: auto;">100% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Identity verified through KYC process. Full reward eligibility.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--lcars-gold);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Agent Certified</span>
                                <span style="color: var(--lcars-gold-light); margin-left: auto;">120% Rewards</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Premium tier with bonus rewards. Requires additional certification.</p>
                        </div>
                        <div class="info-box">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--accent-danger);"></div>
                                <span style="color: var(--text-primary); font-weight: 600;">Cooldown Period</span>
                                <span style="color: var(--accent-danger); margin-left: auto;">100 blocks</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-muted);">Unstaking requires a cooldown period before funds are released.</p>
                        </div>
                    </div>

                    <div class="section-title">Staking Actions</div>
                    <div class="info-box" style="margin-bottom: 24px;">
                        <div class="grid-2" style="gap: 16px;">
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Stake Amount (QMHY)</label>
                                    <input type="number" class="form-input" id="stakeAmount" placeholder="1000">
                                </div>
                                <button class="btn btn-success" onclick="stakeTokens()">STAKE</button>
                            </div>
                            <div>
                                <div class="form-group">
                                    <label class="form-label">Unstake Amount (QMHY)</label>
                                    <input type="number" class="form-input" id="unstakeAmount" placeholder="1000">
                                </div>
                                <button class="btn btn-danger" onclick="requestUnstake()">REQUEST UNSTAKE</button>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Reward Actions</div>
                    <div style="display: flex; gap: 12px; margin-bottom: 24px;">
                        <button class="btn btn-primary" onclick="claimRewards()">CLAIM REWARDS</button>
                        <button class="btn btn-secondary" onclick="submitUptimeProof()">SUBMIT UPTIME PROOF</button>
                        <button class="btn btn-secondary" onclick="refreshRewards()">REFRESH</button>
                    </div>

                    <div class="section-title">
                        <span>Unstake Queue</span>
                    </div>
                    <div class="info-box" id="unstakeQueue">
                        <div class="info-row">
                            <span class="info-label">No pending unstake requests</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearRewardsConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="rewardsTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Rewards console ready</div>
                    </div>
                </div>

                <!-- RUNTIME PANEL -->
                <div id="panel-runtime" class="panel">
                    <h2 class="panel-title">Runtime Upgrade</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Spec Version</div>
                            <div class="stat-value green" id="specVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Impl Version</div>
                            <div class="stat-value" id="implVersion">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Upgrade Method</div>
                            <div class="stat-value blue" id="upgradeMethod">Auto</div>
                        </div>
                    </div>

                    <div class="section-title">Sudo Key (Required)</div>
                    <div class="info-box" style="margin-bottom: 16px;">
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label class="form-label">Sudo Secret Key</label>
                            <input type="password" class="form-input" id="sudoSecretKey" placeholder="alice, bob, charlie, or paste 128-byte hex key">
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted);">
                            Validator aliases: <code style="color: var(--lcars-gold);">alice</code>, <code style="color: var(--lcars-gold);">bob</code>, <code style="color: var(--lcars-gold);">charlie</code> |
                            Or paste full 128-byte SPHINCS+ secret key (hex)
                        </div>
                    </div>

                    <div class="section-title">Upload Runtime WASM</div>
                    <div class="file-drop" id="wasmDropZone" onclick="document.getElementById('wasmFile').click()">
                        <div class="file-drop-icon">ðŸ“¦</div>
                        <div style="font-size: 16px; margin-bottom: 8px;">Drop WASM file here</div>
                        <div style="font-size: 12px; color: var(--text-muted);">or click to browse</div>
                        <input type="file" id="wasmFile" accept=".wasm" style="display: none;" onchange="handleWasmSelect(this)">
                    </div>

                    <div class="info-box" id="wasmInfo" style="display: none; margin-top: 16px;">
                        <div class="info-row">
                            <span class="info-label">File</span>
                            <span class="info-value" id="wasmFileName">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Size</span>
                            <span class="info-value" id="wasmFileSize">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">SHA256</span>
                            <span class="info-value" id="wasmHash" style="font-size: 10px;">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Method</span>
                            <span class="info-value" id="wasmMethod">---</span>
                        </div>
                    </div>

                    <!-- Progress Bar -->
                    <div id="upgradeProgress" style="display: none; margin-top: 16px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span id="progressPhase" style="font-size: 12px; color: var(--text-secondary);">Preparing...</span>
                            <span id="progressPercent" style="font-size: 12px; color: var(--lcars-gold);">0%</span>
                        </div>
                        <div style="height: 8px; background: var(--bg-surface); border-radius: 4px; overflow: hidden;">
                            <div id="progressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--lcars-gold), var(--accent-success)); transition: width 0.3s ease;"></div>
                        </div>
                        <div id="progressDetails" style="font-size: 11px; color: var(--text-muted); margin-top: 4px;"></div>
                    </div>

                    <div style="margin-top: 24px; display: flex; gap: 12px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="submitRuntimeUpgradeV2()" id="upgradeBtn">SUBMIT UPGRADE</button>
                        <button class="btn btn-secondary" onclick="submitRuntimeUpgradeV2(true)" id="chunkedBtn">CHUNKED UPGRADE</button>
                        <button class="btn btn-secondary" onclick="clearWasm()">CLEAR</button>
                    </div>

                    <div class="section-title" style="margin-top: 24px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearRuntimeConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="runtimeTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Runtime console ready</div>
                    </div>
                </div>

                <!-- KEYS PANEL -->
                <div id="panel-keys" class="panel">
                    <h2 class="panel-title">Key Management</h2>

                    <!-- ACCOUNT SECTION - For receiving tokens -->
                    <div class="section-title" style="color: var(--lcars-gold);">Your Account (for Faucet & Transfers)</div>
                    <div class="info-box" style="border: 1px solid var(--lcars-gold-dim); margin-bottom: 16px;">
                        <div class="info-row">
                            <span class="info-label">Your Address</span>
                            <span class="info-value" id="myAccountDisplay" style="font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--lcars-gold);">No account - click CREATE ACCOUNT</span>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="generateAccount()">CREATE ACCOUNT</button>
                            <button class="btn btn-secondary" onclick="copyMyAddress()">COPY ADDRESS</button>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; color: var(--text-muted);">
                            Create an account to receive QMHY tokens from the faucet. Your address will appear in the header.
                        </div>
                    </div>

                    <!-- SESSION KEYS SECTION - For validators -->
                    <div class="section-title">Session Keys (for Validators)</div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Keystore Path</span>
                            <span class="info-value" id="keystorePath" style="font-size: 11px;">~/Library/Application Support/quantumharmony/operator-keystore/</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Algorithm</span>
                            <span class="info-value">SPHINCS+-256s (Post-Quantum)</span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px; margin: 16px 0; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="checkKeystore()">CHECK KEYSTORE</button>
                        <button class="btn btn-secondary" onclick="generateKey()">ROTATE SESSION KEYS</button>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 16px;">
                        Session keys are used for block production. Only needed if you're running a validator node.
                    </div>

                    <div class="section-title">
                        <span>Validator Keys</span>
                        <span id="keysCount" style="color: var(--lcars-gold);">0 keys</span>
                    </div>
                    <div class="info-box" id="keysListBox">
                        <div class="info-row" id="noKeysMsg">
                            <span class="info-label">No keys found. Click CHECK KEYSTORE or GENERATE NEW KEY.</span>
                        </div>
                    </div>

                    <div class="section-title">Key Injection (Advanced)</div>
                    <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 12px; color: var(--text-muted);">
                        <strong style="color: var(--accent-warning);">Note:</strong> Dev seeds (Alice, Bob) generate random test keys.
                        For production, use GENERATE NEW KEY and register the public key with the network.
                    </div>
                    <div class="form-group">
                        <label class="form-label">Key Injection</label>
                        <input type="text" class="form-input" id="sudoSeed" placeholder="alice/bob/charlie OR 0x... (256-char secret key)">
                        <small style="color: #888; display: block; margin-top: 4px;">Enter dev account name or SPHINCS+ secret key (128 bytes / 256 hex chars)</small>
                    </div>
                    <button class="btn btn-secondary" onclick="injectKey()">INJECT KEY</button>

                    <div class="section-title" style="margin-top: 32px;">
                        <span>Console Output</span>
                        <button class="btn btn-secondary btn-sm" onclick="clearKeysConsole()">CLEAR</button>
                    </div>
                    <div class="terminal" id="keysTerminal" style="max-height: 180px;">
                        <div class="terminal-line info">Keys console ready</div>
                    </div>
                </div>

                <!-- QUANTUM PANEL -->
                <div id="panel-quantum" class="panel">
                    <h2 class="panel-title">Quantum Services</h2>

                    <div class="section-title">Entropy Source</div>
                    <div class="form-group">
                        <select class="form-input" id="entropySource" onchange="onEntropySourceChange()">
                            <option value="hub">Entropy Hub (Aggregator)</option>
                            <option value="crypto4a">Crypto4A QRNG</option>
                            <option value="qkd">QKD Device</option>
                        </select>
                    </div>

                    <div class="grid-2">
                        <div>
                            <div class="section-title">QKD Client</div>
                            <div class="status-pill" id="qkdStatus" style="margin-bottom: 16px;">
                                <div class="dot"></div>
                                <span class="status-pill-text" id="qkdStatusText">Checking...</span>
                            </div>
                            <div class="info-box">
                                <div class="info-row">
                                    <span class="info-label">Device</span>
                                    <span class="info-value" id="qkdDevice">---</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Keys Available</span>
                                    <span class="info-value" id="qkdKeys">---</span>
                                </div>
                            </div>
                        </div>

                        <div>
                            <div class="section-title">Entropy Hub</div>
                            <div class="status-pill" id="hubStatus" style="margin-bottom: 16px;">
                                <div class="dot"></div>
                                <span class="status-pill-text" id="hubStatusText">Checking...</span>
                            </div>
                            <div class="info-box">
                                <div class="info-row">
                                    <span class="info-label">Active Sources</span>
                                    <span class="info-value" id="hubSources">---</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Pool Size</span>
                                    <span class="info-value" id="hubPool">---</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Crypto4A HSM (QRNG/RNG Entropy)</div>
                    <div class="info-box" id="crypto4aRngBox">
                        <div class="info-row">
                            <span class="info-label">Description</span>
                            <span class="info-value" style="font-size: 11px; color: var(--text-muted);">Hardware entropy source (does not store keys)</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Endpoint</span>
                            <input type="text" class="form-input" id="crypto4aEndpoint" value="http://localhost:8106/v1/random" style="margin-top: 8px;">
                        </div>
                        <div class="info-row">
                            <span class="info-label">Status</span>
                            <span class="info-value" id="crypto4aStatus">Not Tested</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Last Entropy</span>
                            <span class="info-value" id="crypto4aEntropy" style="font-size: 10px;">---</span>
                        </div>
                    </div>
                    <div style="margin-top: 16px; display: flex; gap: 12px;">
                        <button class="btn btn-primary" onclick="testCrypto4aRng()">TEST RNG</button>
                        <button class="btn btn-secondary" onclick="fetchCrypto4aEntropy(32)">FETCH 32 BYTES</button>
                    </div>
                </div>

                <!-- NETWORK PANEL -->
                <div id="panel-network" class="panel">
                    <h2 class="panel-title">Network Topology</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Connected Peers</div>
                            <div class="stat-value blue" id="networkPeers">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Best Block</div>
                            <div class="stat-value" id="networkBest">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Finalized</div>
                            <div class="stat-value green" id="networkFinalized">---</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Network Health</div>
                            <div class="stat-value" id="networkHealth" style="color: var(--accent-success);">---</div>
                        </div>
                    </div>

                    <div class="section-title">Toroidal Mesh Topology</div>
                    <div style="background: var(--bg-surface); border-radius: var(--radius-md); padding: var(--space-3); margin-bottom: var(--space-3);">
                        <canvas id="networkCanvas" width="600" height="400" style="width: 100%; max-width: 600px; display: block; margin: 0 auto; border-radius: var(--radius-sm);"></canvas>
                    </div>

                    <div class="section-title">Validator Nodes</div>
                    <div id="validatorNodes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-3);">
                        <!-- Validator cards will be populated by JS -->
                    </div>

                    <div class="section-title" style="margin-top: var(--space-4);">Peer Connections</div>
                    <div class="info-box" id="peersList" style="max-height: 200px; overflow-y: auto;">
                        <div class="info-row">
                            <span class="info-label">Fetching peers...</span>
                        </div>
                    </div>
                </div>

                <!-- REPORTER PANEL -->
                <div id="panel-reporter" class="panel">
                    <h2 class="panel-title">Price Oracle Reporter</h2>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Reporter Status</div>
                            <div class="stat-value" id="reporterStatus" style="color: var(--text-muted);">Not Registered</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Reputation</div>
                            <div class="stat-value blue" id="reporterReputation">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Submissions</div>
                            <div class="stat-value green" id="reporterSubmissions">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Success Rate</div>
                            <div class="stat-value gold" id="reporterSuccessRate">--%</div>
                        </div>
                    </div>

                    <div class="section-title">Register as Reporter</div>
                    <div class="form-group">
                        <label class="form-label">Reporter ID</label>
                        <input type="text" class="form-input" id="reporterId" placeholder="e.g., paraxiom-oracle-1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Account Address</label>
                        <input type="text" class="form-input" id="reporterAccount" placeholder="5xxxxx... (SS58 address)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Price Feeds</label>
                        <div style="display: flex; gap: var(--space-2); flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="checkbox" id="feedCADUSD" checked> CAD/USD
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="checkbox" id="feedQMHYUSD"> QMHY/USD
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="checkbox" id="feedQCADCAD"> QCAD/CAD
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="registerReporterBtn" onclick="registerReporter()">Register as Reporter</button>

                    <div class="section-title" style="margin-top: var(--space-4);">Submit Price</div>
                    <div class="form-group">
                        <label class="form-label">Price Feed</label>
                        <select class="form-input" id="priceFeed">
                            <option value="CAD/USD">CAD/USD</option>
                            <option value="QMHY/USD">QMHY/USD</option>
                            <option value="QCAD/CAD">QCAD/CAD</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Price (8 decimals)</label>
                        <input type="text" class="form-input" id="priceValue" placeholder="e.g., 0.73456789">
                    </div>
                    <button class="btn btn-primary" id="submitPriceBtn" onclick="submitPrice()">Submit Price</button>

                    <div class="section-title" style="margin-top: var(--space-4);">External Price Adapters</div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">Binance API</span>
                            <span class="info-value" id="binanceStatus" style="color: var(--text-muted);">Not Connected</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Kraken API</span>
                            <span class="info-value" id="krakenStatus" style="color: var(--text-muted);">Not Connected</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Chainlink Feed</span>
                            <span class="info-value" id="chainlinkStatus" style="color: var(--text-muted);">Not Connected</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: var(--space-4);">Current Oracle Prices</div>
                    <div class="info-box" id="oraclePrices">
                        <div class="info-row">
                            <span class="info-label">CAD/USD</span>
                            <span class="info-value" id="priceCADUSD">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">QMHY/USD</span>
                            <span class="info-value" id="priceQMHYUSD">--</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">QCAD/CAD</span>
                            <span class="info-value" id="priceQCADCAD">--</span>
                        </div>
                    </div>

                    <div class="section-title" style="margin-top: var(--space-4);">Active Reporters</div>
                    <div class="info-box" id="reportersList" style="max-height: 200px; overflow-y: auto;">
                        <div class="info-row">
                            <span class="info-label" style="color: var(--text-muted);">Loading reporters...</span>
                        </div>
                    </div>
                </div>

                <!-- SETTINGS PANEL -->
                <div id="panel-settings" class="panel">
                    <h2 class="panel-title">Settings</h2>

                    <div class="form-group">
                        <label class="form-label">RPC Endpoint</label>
                        <input type="text" class="form-input" id="settingsRpc" value="http://localhost:9944">
                    </div>
                    <div class="form-group">
                        <label class="form-label">QKD Endpoint</label>
                        <input type="text" class="form-input" id="settingsQkd" value="http://localhost:8181">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Entropy Hub</label>
                        <input type="text" class="form-input" id="settingsHub" value="http://localhost:8180">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Controller</label>
                        <input type="text" class="form-input" id="settingsController" value="http://localhost:9955">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Console Log Level</label>
                        <select class="form-input" id="settingsLogLevel" onchange="setLogLevel(parseInt(this.value))">
                            <option value="0">Errors Only</option>
                            <option value="1" selected>Info (default)</option>
                            <option value="2">Verbose (all RPC)</option>
                        </select>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-primary" onclick="saveSettings()">SAVE</button>
                        <button class="btn btn-secondary" onclick="loadSettings()">RESET</button>
                    </div>
                </div>

                <!-- PROOFS PANEL -->
                <div id="panel-proofs" class="panel">
                    <h2 class="panel-title">Cryptographic Proofs & Tests</h2>

                    <!-- Stats Overview -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">PALLET TESTS</div>
                            <div class="stat-value green" id="proofTotalTests">164</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">PALLETS COVERED</div>
                            <div class="stat-value blue" id="proofPassedTests">8</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">PEDERSEN PROOFS</div>
                            <div class="stat-value blue" id="proofPedersen">21</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">STATUS</div>
                            <div class="stat-value gold" id="proofStatus">VERIFIED</div>
                        </div>
                    </div>

                    <!-- Proof Systems -->
                    <div class="section-title">Active Proof Systems by Pallet</div>
                    <div class="info-box" style="font-size: 12px;">
                        <div class="info-row"><span class="info-label">pallet-ricardian-contracts</span><span class="info-value" style="color: var(--accent-success);">32 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-academic-vouch</span><span class="info-value" style="color: var(--accent-success);">32 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-notarial</span><span class="info-value" style="color: var(--accent-success);">29 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-pedersen-commitment</span><span class="info-value" style="color: var(--accent-success);">21 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-fideicommis</span><span class="info-value" style="color: var(--accent-success);">18 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-stablecoin</span><span class="info-value" style="color: var(--accent-success);">14 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-relay-coordination</span><span class="info-value" style="color: var(--accent-success);">11 tests</span></div>
                        <div class="info-row"><span class="info-label">pallet-validator-entropy</span><span class="info-value" style="color: var(--accent-success);">7 tests</span></div>
                    </div>

                    <!-- Pedersen Commitment Deep Dive -->
                    <div class="section-title">Pedersen Commitment Scheme - Technical Details</div>
                    <div style="background: var(--bg-elevated); border-radius: var(--radius-md); padding: var(--space-4); margin-bottom: var(--space-4);">
                        <h4 style="color: var(--lcars-gold); margin-bottom: 12px; font-family: 'Orbitron', monospace;">What is a Pedersen Commitment?</h4>
                        <p style="color: var(--text-secondary); font-size: 12px; line-height: 1.6; margin-bottom: 16px;">
                            A Pedersen commitment is a cryptographic primitive that allows you to commit to a value while keeping it hidden, with the ability to reveal it later. It provides two critical security properties:
                        </p>
                        <div class="grid-2" style="gap: 16px; margin-bottom: 16px;">
                            <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; border-left: 3px solid var(--accent-success);">
                                <strong style="color: var(--accent-success);">Information-Theoretic Hiding</strong>
                                <p style="color: var(--text-muted); font-size: 11px; margin-top: 4px;">
                                    Even with unlimited computational power, an attacker cannot determine the committed value from the commitment alone. The blinding factor makes every possible value equally likely.
                                </p>
                            </div>
                            <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; border-left: 3px solid var(--lcars-blue);">
                                <strong style="color: var(--lcars-blue);">Computational Binding</strong>
                                <p style="color: var(--text-muted); font-size: 11px; margin-top: 4px;">
                                    Once committed, you cannot open the commitment to a different value. Breaking this requires solving the discrete logarithm problem on the elliptic curve.
                                </p>
                            </div>
                        </div>

                        <h4 style="color: var(--lcars-gold); margin-bottom: 12px; font-family: 'Orbitron', monospace;">Mathematical Foundation</h4>
                        <div style="background: #0a0a0f; padding: 16px; border-radius: 8px; font-family: 'JetBrains Mono', monospace; font-size: 11px; margin-bottom: 16px;">
                            <div style="color: var(--text-muted); margin-bottom: 8px;">// BLS12-381 Curve Parameters</div>
                            <div><span style="color: var(--lcars-gold);">Curve:</span> BLS12-381 (Barreto-Lynn-Scott)</div>
                            <div><span style="color: var(--lcars-gold);">Group:</span> G1 (381-bit prime field)</div>
                            <div><span style="color: var(--lcars-gold);">Order:</span> r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001</div>
                            <div style="margin-top: 12px; color: var(--text-muted);">// Commitment Formula</div>
                            <div style="color: var(--accent-success);">C = g<sup>entropy</sup> Ã— h<sup>blinding</sup></div>
                            <div style="margin-top: 8px; color: var(--text-muted);">where:</div>
                            <div>  g = G1 generator (standard)</div>
                            <div>  h = hash_to_curve("qh_pedersen_h") // Nothing-up-my-sleeve point</div>
                            <div>  entropy = 32 bytes of quantum randomness</div>
                            <div>  blinding = 32 bytes of secret randomness</div>
                            <div style="margin-top: 12px; color: var(--text-muted);">// Output</div>
                            <div>Commitment size: <span style="color: var(--lcars-blue);">48 bytes</span> (compressed G1 point)</div>
                        </div>

                        <h4 style="color: var(--lcars-gold); margin-bottom: 12px; font-family: 'Orbitron', monospace;">Protocol Flow in QuantumHarmony</h4>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                            <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--lcars-gold); font-size: 24px; font-weight: bold;">1</div>
                                <div style="color: var(--text-primary); font-size: 12px; font-weight: bold;">COMMIT</div>
                                <div style="color: var(--text-muted); font-size: 10px;">Block N: Validator computes C and submits on-chain. Entropy is HIDDEN.</div>
                            </div>
                            <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--lcars-gold); font-size: 24px; font-weight: bold;">2</div>
                                <div style="color: var(--text-primary); font-size: 12px; font-weight: bold;">WAIT</div>
                                <div style="color: var(--text-muted); font-size: 10px;">At least 1 block must pass. Prevents same-block reveal attacks.</div>
                            </div>
                            <div style="background: var(--bg-surface); padding: 12px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--lcars-gold); font-size: 24px; font-weight: bold;">3</div>
                                <div style="color: var(--text-primary); font-size: 12px; font-weight: bold;">REVEAL</div>
                                <div style="color: var(--text-muted); font-size: 10px;">Block N+1: Submit (entropy, blinding). Network verifies C' = C.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Use Cases -->
                    <div class="section-title">Pedersen Commitment Use Cases</div>
                    <div class="info-box" style="font-size: 11px;">
                        <div class="info-row">
                            <span class="info-label">Quantum Entropy Aggregation</span>
                            <span class="info-value" style="color: var(--text-muted);">Validators commit entropy before revealing, preventing front-running</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">MEV Protection</span>
                            <span class="info-value" style="color: var(--text-muted);">Transaction ordering hidden during mempool validation phase</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Confidential Voting</span>
                            <span class="info-value" style="color: var(--text-muted);">Governance votes committed before reveal to prevent bandwagoning</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Sealed-Bid Auctions</span>
                            <span class="info-value" style="color: var(--text-muted);">Bid amounts hidden until reveal phase in NFT/asset auctions</span>
                        </div>
                    </div>

                    <!-- Test Console -->
                    <div class="section-title">
                        <span>Test Console</span>
                        <button class="btn btn-primary" onclick="runProofTests()" style="padding: 4px 12px; font-size: 10px;">RUN ALL TESTS</button>
                    </div>
                    <div id="proofConsole" style="
                        background: #0a0a0f;
                        border: 1px solid var(--lcars-gold-dark);
                        border-radius: var(--radius-md);
                        padding: var(--space-3);
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 11px;
                        max-height: 250px;
                        overflow-y: auto;
                        color: var(--text-secondary);
                    ">
<span style="color: #888;">$ cargo test --workspace</span>

<span style="color: var(--lcars-gold);">running 21 tests (pallet-pedersen-commitment)</span>
<span style="color: var(--accent-success);">test test_create_commitment_point_deterministic ... ok</span>
<span style="color: var(--accent-success);">test test_verify_commitment_correct ... ok</span>
<span style="color: var(--accent-success);">test test_information_theoretic_hiding ... ok</span>
<span style="color: var(--accent-success);">test test_binding_property ... ok</span>
<span style="color: #888;">... +17 more tests</span>

<span style="color: var(--lcars-gold);">running 32 tests (pallet-ricardian-contracts)</span>
<span style="color: var(--accent-success);">test tests::create_contract_works ... ok</span>
<span style="color: var(--accent-success);">test tests::sign_contract_works ... ok</span>
<span style="color: #888;">... +30 more tests</span>

<span style="color: var(--lcars-gold);">running 29 tests (pallet-notarial)</span>
<span style="color: var(--accent-success);">test tests::attest_document_works ... ok</span>
<span style="color: #888;">... +28 more tests</span>

<span style="color: var(--accent-success); font-weight: bold;">test result: ok. 164 passed; 0 failed; 0 ignored</span>
                    </div>

                    <!-- Live Pedersen Commitment Demo -->
                    <div class="section-title">Interactive Pedersen Commitment Demo</div>
                    <div class="grid-2">
                        <div>
                            <div class="form-group">
                                <label class="form-label">Entropy Value (32 bytes hex)</label>
                                <input type="text" class="form-input" id="proofEntropy" value="2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a" style="font-family: 'JetBrains Mono', monospace; font-size: 10px;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">This is the secret value you want to commit to (e.g., quantum entropy)</div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Blinding Factor (32 bytes hex)</label>
                                <input type="text" class="form-input" id="proofBlinding" value="6363636363636363636363636363636363636363636363636363636363636363" style="font-family: 'JetBrains Mono', monospace; font-size: 10px;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">Random value that hides the entropy (must keep secret until reveal)</div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-success" onclick="computePedersenCommitment()">COMPUTE</button>
                                <button class="btn btn-secondary" onclick="generateRandomInputs()">RANDOM</button>
                            </div>
                        </div>
                        <div>
                            <div class="info-box" style="height: 100%;">
                                <div class="info-row">
                                    <span class="info-label">Formula</span>
                                    <span class="info-value" style="font-size: 11px; font-family: 'JetBrains Mono', monospace;">C = g<sup>e</sup> Ã— h<sup>b</sup></span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Curve</span>
                                    <span class="info-value">BLS12-381 G1</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Commitment (48 bytes)</span>
                                    <span class="info-value" id="proofCommitmentResult" style="font-size: 9px; word-break: break-all; color: var(--lcars-blue-light);">Click COMPUTE to generate</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Security Level</span>
                                    <span class="info-value" style="font-size: 10px; color: var(--accent-success);">128-bit (quantum-resistant curve)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Verification Demo -->
                    <div class="section-title">Document Hash Verification (Blake2-256)</div>
                    <div class="form-group">
                        <label class="form-label">Document Text</label>
                        <textarea class="form-input" id="proofDocText" rows="2" style="font-family: 'JetBrains Mono', monospace; font-size: 11px;">QuantumHarmony Notarial Attestation - Timestamped Proof of Existence</textarea>
                    </div>
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="computeDocumentHash()">COMPUTE HASH</button>
                        <button class="btn btn-secondary" onclick="verifyDocumentHash()">VERIFY</button>
                    </div>
                    <div class="info-box">
                        <div class="info-row">
                            <span class="info-label">SHA-256 Hash</span>
                            <span class="info-value" id="proofDocHash" style="font-size: 10px; word-break: break-all; font-family: 'JetBrains Mono', monospace;">---</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Verification</span>
                            <span class="info-value" id="proofDocVerify" style="color: var(--text-muted);">Not verified</span>
                        </div>
                    </div>
                </div>

                <!-- MESSAGES PANEL -->
                <div id="panel-messages" class="panel">
                    <h2 class="panel-title">Validator Messaging (Post-Quantum Encrypted)</h2>

                    <!-- Identity Status -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">MY IDENTITY</div>
                            <div class="stat-value blue" id="msgFingerprint" style="font-size: 12px;">Not initialized</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">PEERS</div>
                            <div class="stat-value gold" id="msgPeerCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">UNREAD</div>
                            <div class="stat-value green" id="msgUnreadCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">ENCRYPTION</div>
                            <div class="stat-value" style="font-size: 10px; color: var(--accent-success);">ML-KEM-768 + X25519</div>
                        </div>
                    </div>

                    <!-- Initialize Button -->
                    <div class="control-bar">
                        <button class="btn btn-success" onclick="initMessaging()" id="initMsgBtn">INITIALIZE</button>
                        <button class="btn btn-primary" onclick="refreshMessages()">REFRESH</button>
                        <button class="btn btn-secondary" onclick="showMyBundle()">SHOW MY BUNDLE</button>
                    </div>

                    <div class="grid-2">
                        <!-- Left: Chat Area -->
                        <div>
                            <div class="section-title">Messages</div>
                            <div id="msgChatArea" style="
                                background: #0a0a0f;
                                border: 1px solid var(--lcars-gold-dark);
                                border-radius: var(--radius-md);
                                padding: var(--space-3);
                                height: 300px;
                                overflow-y: auto;
                                font-family: 'JetBrains Mono', monospace;
                                font-size: 11px;
                            ">
                                <div style="color: var(--text-muted); text-align: center; padding: 20px;">
                                    Initialize messaging to start secure communication with other validators.
                                </div>
                            </div>

                            <!-- Send Message -->
                            <div style="margin-top: var(--space-3);">
                                <div class="form-group">
                                    <label class="form-label">Recipient Fingerprint</label>
                                    <input type="text" class="form-input" id="msgRecipient" placeholder="e.g. 6bafb1037350eebd" style="font-family: 'JetBrains Mono', monospace;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Message</label>
                                    <textarea class="form-input" id="msgContent" rows="2" placeholder="Type your message..."></textarea>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-success" onclick="sendMessage()">SEND</button>
                                    <select id="msgType" class="form-input" style="width: auto;">
                                        <option value="text">Text</option>
                                        <option value="maintenance">Maintenance Notice</option>
                                        <option value="alert">Alert</option>
                                        <option value="online">Online Notice</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Right: Peers & Bundle -->
                        <div>
                            <div class="section-title">Known Peers</div>
                            <div id="msgPeerList" class="info-box" style="max-height: 150px; overflow-y: auto;">
                                <div style="color: var(--text-muted); font-size: 11px;">No peers added yet</div>
                            </div>

                            <div class="section-title" style="margin-top: var(--space-3);">Add Peer</div>
                            <div class="form-group">
                                <label class="form-label">Peer's Prekey Bundle (Base64)</label>
                                <textarea class="form-input" id="msgPeerBundle" rows="3" placeholder="Paste peer's bundle here..." style="font-size: 10px;"></textarea>
                            </div>
                            <button class="btn btn-primary" onclick="addPeer()">ADD PEER</button>

                            <!-- My Bundle Display -->
                            <div id="msgMyBundle" style="display: none; margin-top: var(--space-3);">
                                <div class="section-title">My Prekey Bundle (share with peers)</div>
                                <textarea class="form-input" id="msgBundleText" rows="3" readonly style="font-size: 9px;"></textarea>
                                <button class="btn btn-secondary" onclick="copyBundle()" style="margin-top: 8px;">COPY</button>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Footer -->
        <div class="lcars-footer">
            <div class="footer-cap"></div>
            <div class="footer-bar">
                <span class="footer-text" id="footerStatus">Disconnected</span>
            </div>
            <div class="footer-end"></div>
        </div>
    </div>

    <!-- PERSISTENT CHAT BAR - Full width at bottom -->
    <div id="chatBar" style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(180deg, #1a1a2e 0%, #0d0d15 100%);
        border-top: 3px solid #ff9900;
        z-index: 9999;
        font-family: 'JetBrains Mono', monospace;
    ">
        <!-- Expandable Messages Area -->
        <div id="chatMessages" style="
            height: 0;
            max-height: 250px;
            overflow-y: auto;
            padding: 0;
            background: #08080c;
            transition: height 0.3s ease, padding 0.3s ease;
        "></div>

        <!-- Chat Input Bar - Always visible -->
        <div style="display: flex; align-items: center; gap: 10px; padding: 8px 15px; background: #12121a;">
            <!-- Toggle/Status -->
            <div onclick="toggleChat()" style="cursor: pointer; display: flex; align-items: center; gap: 6px;">
                <span style="color: #ff9900; font-weight: bold; font-size: 11px;">CHAT</span>
                <span id="chatUnread" style="background: #ff4444; color: white; font-size: 9px; padding: 1px 5px; border-radius: 8px; display: none;">0</span>
                <span id="chatToggleIcon" style="color: #ff9900; font-size: 10px;">â–²</span>
            </div>

            <!-- My ID -->
            <span id="chatFingerprint" style="color: #6699ff; font-size: 10px; padding: 4px 8px; background: rgba(100,150,255,0.1); border-radius: 4px; cursor: pointer;" onclick="showChatBundle()" title="Click to copy your bundle">--</span>

            <!-- Validator Selector -->
            <select id="chatRecipient" style="
                background: #0a0a0f;
                border: 1px solid #ff9900;
                color: #fff;
                padding: 6px 10px;
                border-radius: 4px;
                font-size: 11px;
                font-family: monospace;
                min-width: 150px;
            ">
                <option value="">Select recipient...</option>
                <option value="ALL">-- ALL VALIDATORS --</option>
                <option value="97e3988b8c7e6f40">Alice (97e3988b)</option>
                <option value="6bafb1037350eebd">Bob (6bafb103)</option>
            </select>

            <!-- Message Input -->
            <input type="text" id="chatInput" placeholder="Type message and press Enter..." onkeypress="if(event.key==='Enter')sendChatMessage()" style="
                flex: 1;
                background: #0a0a0f;
                border: 1px solid #444;
                color: #fff;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
            ">

            <!-- Message Type -->
            <select id="chatMsgType" style="
                background: #0a0a0f;
                border: 1px solid #444;
                color: #fff;
                padding: 6px 8px;
                border-radius: 4px;
                font-size: 10px;
            ">
                <option value="text">Text</option>
                <option value="alert">Alert</option>
                <option value="maintenance">Maintenance</option>
            </select>

            <!-- Send Button -->
            <button onclick="sendChatMessage()" style="
                background: linear-gradient(135deg, #00cc66 0%, #009944 100%);
                border: none;
                color: #000;
                padding: 8px 20px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
            ">SEND</button>

            <!-- Init Button (shows if not initialized) -->
            <button onclick="initChatMessaging()" id="chatInitBtn" style="
                background: #ff9900;
                border: none;
                color: #000;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
            ">INIT</button>
        </div>
    </div>

    <script>
        // Configuration - auto-detect RPC endpoint based on page location
        // Force clear bad cache if ?reset in URL
        if (window.location.search.includes('reset')) {
            localStorage.clear();
            window.location.href = window.location.pathname;
        }

        // Use nginx proxy to avoid CORS issues
        const RPC_URL = '/rpc';

        let config = {
            rpc: RPC_URL,
            qkd: 'http://localhost:8181',
            hub: 'http://localhost:8180',
            controller: window.location.origin
        };

        let connected = false;
        let selectedWasm = null;
        let sudoAccount = null;
        let agentModeEnabled = localStorage.getItem('agentMode') === 'true';

        // ===========================================
        // USER MENU & AVATAR FUNCTIONS
        // ===========================================

        function toggleUserMenu() {
            const menu = document.getElementById('userMenu');
            const avatarMenu = document.getElementById('avatarMenu');
            avatarMenu.style.display = 'none';
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            event.stopPropagation();
        }

        function closeUserMenu() {
            document.getElementById('userMenu').style.display = 'none';
        }

        function toggleAvatarMenu() {
            const menu = document.getElementById('avatarMenu');
            const userMenu = document.getElementById('userMenu');
            userMenu.style.display = 'none';
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            event.stopPropagation();
        }

        function closeAvatarMenu() {
            document.getElementById('avatarMenu').style.display = 'none';
        }

        // Close menus when clicking outside
        document.addEventListener('click', () => {
            closeUserMenu();
            closeAvatarMenu();
        });

        function uploadAvatar() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const placeholder = document.getElementById('avatarPlaceholder');
                        placeholder.innerHTML = `<img src="${ev.target.result}" alt="Avatar">`;
                        localStorage.setItem('avatar', ev.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
            closeAvatarMenu();
        }

        // Load saved avatar on init
        function loadAvatar() {
            const saved = localStorage.getItem('avatar');
            if (saved) {
                document.getElementById('avatarPlaceholder').innerHTML = `<img src="${saved}" alt="Avatar">`;
            }
        }

        // ===========================================
        // ACCOUNT MANAGEMENT - SS58 Address Display
        // ===========================================

        let myAccountAddress = null;

        // Set and display the current account address
        function setMyAccount(ss58Address) {
            myAccountAddress = ss58Address;
            localStorage.setItem('myAccount', ss58Address);

            // Show in header badge
            const badge = document.getElementById('accountBadge');
            const badgeAddr = document.getElementById('accountBadgeAddress');
            if (badge && badgeAddr) {
                badge.style.display = 'flex';
                badge.style.alignItems = 'center';
                // Show truncated address: 5GDGYe...h1ToY
                const truncated = ss58Address.substring(0, 6) + '...' + ss58Address.substring(ss58Address.length - 5);
                badgeAddr.textContent = truncated;
            }

            // Update KEYS panel display
            const keysDisplay = document.getElementById('myAccountDisplay');
            if (keysDisplay) {
                keysDisplay.textContent = ss58Address;
            }

            // Update avatar menu
            const operatorAddr = document.getElementById('operatorAddress');
            if (operatorAddr) {
                operatorAddr.textContent = ss58Address;
            }

            log(`Account loaded: ${ss58Address}`, 'info');
        }

        // Load account from localStorage on init
        function loadMyAccount() {
            const saved = localStorage.getItem('myAccount');
            if (saved) {
                setMyAccount(saved);
            }
        }

        // Copy address to clipboard (for faucet)
        function copyMyAddress() {
            if (!myAccountAddress) {
                alert('No account yet!\n\nGo to KEYS tab and click CREATE ACCOUNT to generate one.');
                showPanel('keys');
                return;
            }

            navigator.clipboard.writeText(myAccountAddress).then(() => {
                const badge = document.getElementById('accountBadge');
                const originalBg = badge.style.background;
                badge.style.background = 'var(--accent-success)';
                badge.style.color = 'white';
                setTimeout(() => {
                    badge.style.background = originalBg;
                    badge.style.color = 'var(--lcars-gold)';
                }, 500);
                log(`Address copied to clipboard: ${myAccountAddress}`, 'info');
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback
                prompt('Copy this address for the faucet:', myAccountAddress);
            });
        }

        // Convert hex public key to SS58 address using polkadot-util-crypto
        function hexToSS58(hexPublicKey, ss58Format = 42) {
            try {
                // Clean hex prefix
                const clean = hexPublicKey.replace('0x', '');

                // For SPHINCS+ 64-byte public keys, we need to hash to 32 bytes first
                // using Keccak-256 (matching runtime's account derivation)
                let accountBytes;

                if (clean.length === 128) {
                    // 64-byte SPHINCS+ public key - hash with keccak256
                    const pubBytes = new Uint8Array(64);
                    for (let i = 0; i < 64; i++) {
                        pubBytes[i] = parseInt(clean.substr(i * 2, 2), 16);
                    }
                    // Use polkadot util-crypto keccak
                    if (window.polkadotUtilCrypto && window.polkadotUtilCrypto.keccakAsU8a) {
                        accountBytes = window.polkadotUtilCrypto.keccakAsU8a(pubBytes, 256);
                    } else {
                        console.warn('polkadotUtilCrypto not available, using manual hash');
                        // Fallback: just use first 32 bytes (not correct but allows testing)
                        accountBytes = pubBytes.slice(0, 32);
                    }
                } else if (clean.length === 64) {
                    // Already 32 bytes
                    accountBytes = new Uint8Array(32);
                    for (let i = 0; i < 32; i++) {
                        accountBytes[i] = parseInt(clean.substr(i * 2, 2), 16);
                    }
                } else {
                    throw new Error(`Unexpected key length: ${clean.length / 2} bytes`);
                }

                // Encode to SS58
                if (window.polkadotUtilCrypto && window.polkadotUtilCrypto.encodeAddress) {
                    return window.polkadotUtilCrypto.encodeAddress(accountBytes, ss58Format);
                } else {
                    throw new Error('polkadotUtilCrypto.encodeAddress not available');
                }
            } catch (e) {
                console.error('hexToSS58 error:', e);
                return null;
            }
        }

        // Generate a new account (keypair) for receiving tokens
        async function generateAccount() {
            try {
                // Wait for crypto to be ready
                if (window.polkadotUtilCrypto && window.polkadotUtilCrypto.cryptoWaitReady) {
                    await window.polkadotUtilCrypto.cryptoWaitReady();
                }

                // Get Keyring class - bundles export it differently
                const KeyringClass = window.polkadotKeyring?.Keyring || window.polkadotKeyring || window.Keyring;

                if (!KeyringClass) {
                    throw new Error('Keyring class not found. Try refreshing the page.');
                }

                if (!window.polkadotUtilCrypto?.mnemonicGenerate) {
                    throw new Error('Crypto utilities not loaded. Try refreshing the page.');
                }

                // Create keyring and generate mnemonic
                const keyring = new KeyringClass({ type: 'sr25519', ss58Format: 42 });
                const mnemonic = window.polkadotUtilCrypto.mnemonicGenerate();
                const pair = keyring.addFromMnemonic(mnemonic);

                const address = pair.address;
                setMyAccount(address);

                // Show mnemonic ONCE - user must save it
                alert(`NEW ACCOUNT CREATED!\n\n` +
                      `Address (for faucet):\n${address}\n\n` +
                      `SAVE THIS MNEMONIC - IT WILL NOT BE SHOWN AGAIN:\n${mnemonic}\n\n` +
                      `Your address is now shown in the header. Click to copy for faucet.`);

                log(`New account created: ${address}`, 'info');
                return address;
            } catch (e) {
                console.error('generateAccount error:', e);
                console.log('Available globals:', {
                    polkadotKeyring: typeof window.polkadotKeyring,
                    polkadotUtilCrypto: typeof window.polkadotUtilCrypto,
                    Keyring: typeof window.Keyring
                });
                alert(`Error generating account: ${e.message}\n\nCheck browser console for details.`);
                return null;
            }
        }

        // ===========================================
        // AGENT MODE FUNCTIONS
        // ===========================================

        function toggleAgentMode() {
            agentModeEnabled = !agentModeEnabled;
            localStorage.setItem('agentMode', agentModeEnabled);
            updateAgentModeUI();
            closeUserMenu();

            if (agentModeEnabled) {
                log('AGENT MODE ENABLED - Auto-stake active, governance requires manual intervention', 'warning');
            } else {
                log('Agent Mode disabled - Full manual control', 'info');
            }
        }

        function updateAgentModeUI() {
            // Agent Mode is stealth - only show status in private menu
            // No public banner to prevent strategy revelation
            const statusEl = document.getElementById('agentModeStatus');

            if (agentModeEnabled) {
                statusEl.textContent = 'ON';
                statusEl.style.color = 'var(--accent-success)';
            } else {
                statusEl.textContent = 'OFF';
                statusEl.style.color = 'var(--accent-danger)';
            }
        }

        // Auto-stake check (runs when agent mode is enabled)
        async function checkAutoStake() {
            if (!agentModeEnabled) return;

            // In agent mode, automatically compound rewards
            // Note: This does NOT vote - governance always requires human
            rewardsLog('Agent Mode: Checking for auto-stake opportunities...', 'info');
            // Would call the staking RPC here
        }

        // Log level: 0=errors only, 1=info, 2=verbose (shows all RPC)
        let logLevel = parseInt(localStorage.getItem('logLevel') || '1');

        function setLogLevel(level) {
            logLevel = level;
            localStorage.setItem('logLevel', level);
            log(`Log level set to ${['errors', 'info', 'verbose'][level]}`, 'info');
        }

        // RPC endpoint - same pattern as working wallet
        const RPC = '/rpc';

        async function rpc(method, params = []) {
            try {
                const res = await fetch(RPC, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
                });
                const data = await res.json();
                if (data.error) {
                    console.error('RPC error:', data.error);
                    return null;
                }
                return data.result;
            } catch (e) {
                console.error('RPC fetch error:', method, e);
                return null;
            }
        }

        // Controller Helper
        async function controllerRequest(endpoint, method = 'GET', body = null) {
            try {
                const options = { method, headers: { 'Content-Type': 'application/json' } };
                if (method === 'POST') options.body = body ? JSON.stringify(body) : '{}';
                const res = await fetch(config.controller + endpoint, options);
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        // Node Control
        async function startNode() {
            log('Starting node...', 'warning');
            document.getElementById('startBtn').disabled = true;
            const result = await controllerRequest('/node/start', 'POST');
            document.getElementById('startBtn').disabled = false;
            if (result?.success) {
                log(`Node started (PID: ${result.pid})`, 'info');
            } else {
                log(result?.message || 'Failed to start', 'error');
            }
            updateNodeProcessStatus();
        }

        async function stopNode() {
            log('Stopping node...', 'warning');
            const result = await controllerRequest('/node/stop', 'POST');
            log(result?.success ? 'Node stopped' : (result?.message || 'Failed'), result?.success ? 'info' : 'error');
            updateNodeProcessStatus();
        }

        async function restartNode() {
            log('Restarting node...', 'warning');
            const result = await controllerRequest('/node/restart', 'POST');
            if (result?.success) log(`Node restarted (PID: ${result.pid})`, 'info');
            else log(result?.message || 'Failed', 'error');
            updateNodeProcessStatus();
        }

        async function updateNodeProcessStatus() {
            // Try direct RPC first (preferred - works without controller)
            console.log('[updateNodeProcessStatus] Checking...');
            const health = await rpc('system_health');
            console.log('[updateNodeProcessStatus] Health result:', health);
            const pill = document.getElementById('nodeProcessStatus');
            const text = document.getElementById('nodeProcessText');

            if (health) {
                console.log('[updateNodeProcessStatus] Node is healthy, will call fetchNodeInfo');
                log(`Node healthy: ${health.peers} peers`, 'info');
                pill.classList.remove('offline');
                text.textContent = 'Running';

                // Get block height
                const header = await rpc('chain_getHeader');
                if (header?.number) {
                    const blockNum = parseInt(header.number, 16);
                    document.getElementById('blockHeight').textContent = blockNum.toLocaleString();
                    document.getElementById('networkBest').textContent = blockNum.toLocaleString();
                }

                // Set peers from health
                document.getElementById('peerCount').textContent = health.peers;
                document.getElementById('networkPeers').textContent = health.peers;

                // Set sync status
                document.getElementById('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced';

                // Update connected status
                connected = true;
                document.getElementById('statusDot').classList.add('connected');
                document.getElementById('footerStatus').textContent = 'Connected';

                // Fetch additional node info via RPC
                await fetchNodeInfo();
            } else {
                pill.classList.add('offline');
                text.textContent = 'Offline';
                connected = false;
                document.getElementById('statusDot').classList.remove('connected');
                document.getElementById('footerStatus').textContent = 'Disconnected';
            }
        }

        // Small delay helper
        const delay = ms => new Promise(r => setTimeout(r, ms));

        // Debug function to test RPC directly
        async function debugRPC() {
            const url = config.rpc;
            log(`DEBUG: Testing RPC at ${url}`, 'warning');

            const results = [];

            try {
                // Test 1: system_chain
                log('DEBUG: Testing system_chain...', 'info');
                const res1 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'system_chain', params: [] })
                });
                const data1 = await res1.json();
                results.push(`system_chain: ${data1.result || data1.error?.message || 'failed'}`);
                log(`DEBUG: system_chain = ${data1.result || 'ERROR'}`, data1.result ? 'info' : 'error');

                if (data1.result) {
                    document.getElementById('chainName').textContent = data1.result;
                }
            } catch (e) {
                results.push(`system_chain: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_chain FETCH ERROR: ${e.message}`, 'error');
            }

            await delay(100);

            try {
                // Test 2: system_name
                log('DEBUG: Testing system_name...', 'info');
                const res2 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 2, method: 'system_name', params: [] })
                });
                const data2 = await res2.json();
                results.push(`system_name: ${data2.result || data2.error?.message || 'failed'}`);
                log(`DEBUG: system_name = ${data2.result || 'ERROR'}`, data2.result ? 'info' : 'error');

                if (data2.result) {
                    document.getElementById('nodeName').textContent = data2.result;
                }
            } catch (e) {
                results.push(`system_name: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_name FETCH ERROR: ${e.message}`, 'error');
            }

            await delay(100);

            try {
                // Test 3: system_version
                log('DEBUG: Testing system_version...', 'info');
                const res3 = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 3, method: 'system_version', params: [] })
                });
                const data3 = await res3.json();
                results.push(`system_version: ${data3.result || data3.error?.message || 'failed'}`);
                log(`DEBUG: system_version = ${data3.result || 'ERROR'}`, data3.result ? 'info' : 'error');

                if (data3.result) {
                    document.getElementById('nodeVersion').textContent = data3.result;
                }
            } catch (e) {
                results.push(`system_version: FETCH ERROR - ${e.message}`);
                log(`DEBUG: system_version FETCH ERROR: ${e.message}`, 'error');
            }

            document.getElementById('rpcEndpoint').textContent = url;

            log('DEBUG: Complete. Check Console Output above.', 'warning');
            alert('DEBUG Results:\\n\\n' + results.join('\\n') + '\\n\\nRPC URL: ' + url);
        }

        // Fetch node info (chain, name, version, runtime) via RPC
        async function fetchNodeInfo() {
            console.log('[fetchNodeInfo] Starting...');
            log(`Fetching node info...`, 'info');
            try {
                // Fetch sequentially with small delays to avoid overwhelming RPC
                const chain = await rpc('system_chain');
                await delay(100);

                const name = await rpc('system_name');
                await delay(100);

                const version = await rpc('system_version');
                await delay(100);

                const runtime = await rpc('state_getRuntimeVersion');

                console.log('[fetchNodeInfo] Results:', { chain, name, version, runtime });

                if (chain) {
                    document.getElementById('chainName').textContent = chain;
                    log(`Chain: ${chain}`, 'info');
                } else {
                    log('Chain: failed to fetch', 'error');
                }
                if (name) document.getElementById('nodeName').textContent = name;
                if (version) document.getElementById('nodeVersion').textContent = version;
                if (runtime && runtime.specName) {
                    document.getElementById('runtimeVersion').textContent = `v${runtime.specVersion}`;
                    log(`Runtime: v${runtime.specVersion}`, 'info');
                }
                document.getElementById('rpcEndpoint').textContent = config.rpc;

                // Refresh recent blocks after a short delay
                await delay(200);
                await refreshRecentBlocks();
            } catch (e) {
                log(`fetchNodeInfo error: ${e.message}`, 'error');
                console.error('[fetchNodeInfo] error:', e);
            }
        }

        // Terminal
        function log(message, type = 'info') {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 100) terminal.removeChild(terminal.firstChild);
        }

        function clearTerminal() {
            document.getElementById('terminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        // Navigation
        function showPanel(name) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('panel-' + name).classList.add('active');
            event.target.classList.add('active');
        }

        // Status Updates
        async function updateStatus() {
            try {
                const health = await rpc('system_health');
                const header = await rpc('chain_getHeader');
                const chain = await rpc('system_chain');
                const name = await rpc('system_name');
                const version = await rpc('system_version');
                const runtime = await rpc('state_getRuntimeVersion');

                if (health) {
                    connected = true;
                    document.getElementById('statusDot').classList.add('connected');
                    document.getElementById('footerStatus').textContent = 'Connected';
                    document.getElementById('peerCount').textContent = health.peers || 0;
                    document.getElementById('networkPeers').textContent = health.peers || 0;
                    document.getElementById('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced';
                } else {
                    connected = false;
                    document.getElementById('statusDot').classList.remove('connected');
                    document.getElementById('footerStatus').textContent = 'Disconnected';
                }

                if (header) {
                    const blockNum = parseInt(header.number, 16);
                    document.getElementById('blockHeight').textContent = blockNum.toLocaleString();
                    document.getElementById('networkBest').textContent = blockNum.toLocaleString();
                }

                // Node Information
                if (chain) document.getElementById('chainName').textContent = chain;
                if (name) document.getElementById('nodeName').textContent = name;
                if (version) document.getElementById('nodeVersion').textContent = version;

                // Runtime version - show spec version number
                if (runtime && runtime.specName) {
                    document.getElementById('runtimeVersion').textContent = `v${runtime.specVersion}`;
                    const specEl = document.getElementById('specVersion');
                    const implEl = document.getElementById('implVersion');
                    if (specEl) specEl.textContent = runtime.specVersion;
                    if (implEl) implEl.textContent = runtime.implVersion;
                }

                document.getElementById('rpcEndpoint').textContent = config.rpc;
                document.getElementById('timestamp').textContent = new Date().toLocaleString();

                // Fetch recent blocks on status update
                await refreshRecentBlocks();

                // Fetch and display peers
                await updatePeersList();
            } catch (e) {
                console.error('Status update error:', e);
            }
        }

        // Known validator mapping (legacy - for status tab)
        const KNOWN_VALIDATORS_STATUS = {
            '12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp': { name: 'Alice', ip: '51.79.26.123' },
            '12D3KooWHdiAxVd8uMQR1hGWXccidmfCwLqcMpGwR6QcTP6QRMuD': { name: 'Bob', ip: '51.79.26.168' },
            '12D3KooWSCufgHzV4fCwRijfH2k3abrpAJxTKxEvN1FDuRXA2U9x': { name: 'Charlie', ip: '209.38.225.4' },
        };

        async function updatePeersList() {
            try {
                const peers = await rpc('system_peers');
                const container = document.getElementById('validatorsList');
                if (!container || !peers) return;

                let html = '';
                for (const peer of peers) {
                    const peerId = peer.peerId;
                    const shortId = peerId.substring(0, 16) + '...';
                    const known = KNOWN_VALIDATORS_STATUS[peerId];
                    const name = known ? known.name : 'Unknown';
                    const ip = known ? known.ip : 'external';
                    const role = peer.roles || 'FULL';
                    const bestBlock = peer.bestNumber || 0;
                    const isAuthority = role.includes('AUTHORITY');

                    html += `
                        <div class="info-row" style="border-bottom: 1px solid var(--bg-surface); padding: 8px 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="color: ${isAuthority ? 'var(--lcars-gold)' : 'var(--text-secondary)'}; font-weight: 600;">
                                        ${name}
                                    </span>
                                    <span style="color: var(--text-muted); font-size: 11px; margin-left: 8px;">
                                        ${ip}
                                    </span>
                                </div>
                                <div style="text-align: right;">
                                    <span style="color: ${isAuthority ? 'var(--accent-success)' : 'var(--text-secondary)'}; font-size: 11px;">
                                        ${role}
                                    </span>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                                <span style="color: var(--text-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                                    ${shortId}
                                </span>
                                <span style="color: var(--lcars-blue); font-size: 11px;">
                                    Block #${bestBlock.toLocaleString()}
                                </span>
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html || '<div class="info-row"><span class="info-label">No peers connected</span></div>';
            } catch (e) {
                console.error('updatePeersList error:', e);
            }
        }

        // Recent Blocks with Extrinsics
        let recentBlocks = [];

        async function refreshRecentBlocks() {
            console.log('[refreshRecentBlocks] Starting...');
            const container = document.getElementById('recentBlocksContainer');
            if (!container) {
                console.error('[refreshRecentBlocks] Container not found!');
                return;
            }

            try {
                const header = await rpc('chain_getHeader');
                console.log('[refreshRecentBlocks] Header:', header);
                if (!header) {
                    container.innerHTML = '<div class="info-row"><span class="info-label">Waiting for node connection...</span></div>';
                    return;
                }

                const currentBlock = parseInt(header.number, 16);
                const blocksToFetch = 5;

                let html = '';
                for (let i = 0; i < blocksToFetch; i++) {
                    const blockNum = currentBlock - i;
                    if (blockNum < 0) break;

                    const blockHash = await rpc('chain_getBlockHash', [blockNum]);
                    if (blockHash) {
                        const block = await rpc('chain_getBlock', [blockHash]);
                        if (block && block.block) {
                            const extrinsicsCount = block.block.extrinsics ? block.block.extrinsics.length : 0;

                            html += `
                                <div class="info-row" style="padding: 8px 0; border-bottom: 1px solid var(--bg-surface);">
                                    <div style="display: flex; justify-content: space-between; width: 100%;">
                                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 13px;">
                                            #${blockNum.toLocaleString()}
                                        </span>
                                        <span style="color: var(--accent-success); font-size: 12px;">
                                            ${extrinsicsCount} extrinsic${extrinsicsCount !== 1 ? 's' : ''}
                                        </span>
                                    </div>
                                    <div style="width: 100%; margin-top: 4px;">
                                        <span style="color: var(--text-muted); font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                                            ${blockHash.substring(0, 18)}...${blockHash.substring(blockHash.length - 8)}
                                        </span>
                                    </div>
                                </div>
                            `;
                        }
                    }
                }

                container.innerHTML = html || '<div class="info-row"><span class="info-label">No blocks found</span></div>';
            } catch (e) {
                console.error('Recent blocks error:', e);
                container.innerHTML = '<div class="info-row"><span class="info-label">Error loading blocks</span></div>';
            }
        }

        // WASM
        function handleWasmSelect(input) {
            const file = input.files[0];
            if (!file) return;
            selectedWasm = file;
            document.getElementById('wasmInfo').style.display = 'block';
            document.getElementById('wasmFileName').textContent = file.name;
            document.getElementById('wasmFileSize').textContent = (file.size / 1024).toFixed(2) + ' KB';
            document.getElementById('upgradeBtn').disabled = false;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const hash = await crypto.subtle.digest('SHA-256', e.target.result);
                const hex = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('wasmHash').textContent = '0x' + hex.substring(0, 32) + '...';
            };
            reader.readAsArrayBuffer(file);
            log(`WASM selected: ${file.name}`, 'info');
        }

        function clearWasm() {
            selectedWasm = null;
            document.getElementById('wasmFile').value = '';
            document.getElementById('wasmInfo').style.display = 'none';
            document.getElementById('upgradeBtn').disabled = true;
        }

        // Drag and drop
        const dropZone = document.getElementById('wasmDropZone');
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file?.name.endsWith('.wasm')) {
                document.getElementById('wasmFile').files = e.dataTransfer.files;
                handleWasmSelect(document.getElementById('wasmFile'));
            }
        });

        async function submitRuntimeUpgrade() {
            console.log('submitRuntimeUpgrade called');
            log('Starting runtime upgrade...', 'info');

            if (!selectedWasm) {
                log('No WASM file selected', 'error');
                alert('Please select a WASM file first');
                return;
            }

            // Check for sudo key - either from input or stored
            const sudoKeyInput = document.getElementById('sudoSecretKey')?.value ||
                                 document.getElementById('sudoSeed')?.value;

            if (!sudoKeyInput) {
                log('No sudo key configured', 'error');
                alert('Please enter sudo secret key in KEYS section.\n\nFor dev: use alice, bob, or charlie\nFor production: paste the full 128-byte hex key');
                return;
            }

            const btn = document.getElementById('upgradeBtn');
            btn.disabled = true;
            btn.textContent = 'SUBMITTING...';

            try {
                // Read WASM file as hex
                log('Reading WASM file...', 'info');
                const wasmBytes = await selectedWasm.arrayBuffer();
                const wasmHex = '0x' + Array.from(new Uint8Array(wasmBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                log(`WASM size: ${(wasmBytes.byteLength / 1024).toFixed(2)} KB`, 'info');

                // Determine the secret key to use
                let secretKeyHex;
                let keyInput = sudoKeyInput.trim().replace(/['"]/g, ''); // Remove quotes
                const keyLower = keyInput.toLowerCase();

                // Check if it's a dev account name
                if (keyLower === 'alice' || keyLower === '//alice') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.alice;
                    log('Using Alice dev account', 'info');
                } else if (keyLower === 'bob' || keyLower === '//bob') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.bob;
                    log('Using Bob dev account', 'info');
                } else if (keyLower === 'charlie' || keyLower === '//charlie') {
                    secretKeyHex = '0x' + DEV_ACCOUNTS.charlie;
                    log('Using Charlie dev account', 'info');
                } else {
                    // Treat as hex key - strip 0x prefix if present, then add it back
                    let hexPart = keyInput.startsWith('0x') ? keyInput.slice(2) : keyInput;
                    // Remove any non-hex characters (spaces, newlines, etc)
                    hexPart = hexPart.replace(/[^0-9a-fA-F]/g, '');

                    if (hexPart.length >= 96) {  // At least 48 bytes (seed) or 128 bytes (full key)
                        secretKeyHex = '0x' + hexPart;
                        log(`Using provided key (${hexPart.length / 2} bytes)`, 'info');
                    } else {
                        throw new Error(`Key too short: ${hexPart.length / 2} bytes. Need 48 (seed) or 128 (full key).`);
                    }
                }

                log('Calling quantumharmony_submitRuntimeUpgrade RPC...', 'warning');
                btn.textContent = 'SENDING TO NODE...';

                // Call the custom RPC endpoint
                console.log('RPC call: quantumharmony_submitRuntimeUpgrade');
                console.log('WASM hex length:', wasmHex.length);
                console.log('Secret key length:', secretKeyHex.length);

                let result;
                try {
                    result = await rpc('quantumharmony_submitRuntimeUpgrade', [wasmHex, secretKeyHex]);
                    console.log('RPC result:', result);
                } catch (rpcError) {
                    console.error('RPC error:', rpcError);
                    throw new Error(`RPC failed: ${rpcError.message || rpcError}`);
                }

                if (result) {
                    log('SUCCESS: Runtime upgrade submitted!', 'info');
                    log(`Transaction hash: ${result}`, 'info');
                    btn.textContent = 'SUCCESS!';
                    btn.style.background = 'var(--accent-success)';

                    // Show success alert
                    alert(`Runtime upgrade submitted successfully!\n\nTransaction: ${result}\n\nWaiting for finalization (~12 seconds)...`);

                    // Wait for a few blocks then refresh
                    log('Waiting for finalization (2 blocks)...', 'info');
                    setTimeout(() => {
                        updateStatus();
                        fetchNodeInfo();
                        log('Status refreshed - check spec_version for new version', 'info');
                        alert('Runtime upgrade should now be active. Check the spec_version in STATUS tab.');
                    }, 12000);  // Wait ~2 blocks
                } else {
                    throw new Error('RPC returned empty result - check node logs');
                }

            } catch (error) {
                log(`FAILED: ${error.message}`, 'error');
                console.error('Runtime upgrade error:', error);
                btn.textContent = 'FAILED';
                btn.style.background = 'var(--accent-danger)';
                alert(`Runtime upgrade FAILED!\n\n${error.message}\n\nCheck console for details.`);

                // Reset button after 3 seconds
                setTimeout(() => {
                    btn.style.background = '';
                    btn.textContent = 'SUBMIT UPGRADE';
                }, 3000);
            } finally {
                btn.disabled = false;
            }
        }

        // ============================================
        // RUNTIME UPGRADE V2 - Using UpgradeManager
        // ============================================

        // Runtime console helper
        function runtimeLog(message, type = 'info') {
            const terminal = document.getElementById('runtimeTerminal');
            if (!terminal) return;
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearRuntimeConsole() {
            const terminal = document.getElementById('runtimeTerminal');
            if (terminal) terminal.innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        function updateUpgradeProgress(progressData) {
            const progressDiv = document.getElementById('upgradeProgress');
            const progressBar = document.getElementById('progressBar');
            const progressPhase = document.getElementById('progressPhase');
            const progressPercent = document.getElementById('progressPercent');
            const progressDetails = document.getElementById('progressDetails');

            if (progressDiv) progressDiv.style.display = 'block';
            if (progressBar) progressBar.style.width = `${progressData.progress || 0}%`;
            if (progressPercent) progressPercent.textContent = `${Math.round(progressData.progress || 0)}%`;

            const phaseLabels = {
                preparing: 'Preparing...',
                initiating: 'Initiating chunked upload...',
                uploading: 'Uploading...',
                finalizing: 'Waiting for finalization...',
                submitted: 'Transaction submitted',
                complete: 'Complete!'
            };
            if (progressPhase) progressPhase.textContent = phaseLabels[progressData.phase] || progressData.phase;

            if (progressDetails) {
                if (progressData.chunk && progressData.totalChunks) {
                    progressDetails.textContent = `Chunk ${progressData.chunk}/${progressData.totalChunks}`;
                } else if (progressData.block) {
                    progressDetails.textContent = `Block ${progressData.block}`;
                } else {
                    progressDetails.textContent = '';
                }
            }
        }

        async function submitRuntimeUpgradeV2(forceChunked = false) {
            console.log('submitRuntimeUpgradeV2 called, forceChunked:', forceChunked);

            if (!selectedWasm) {
                runtimeLog('No WASM file selected', 'error');
                alert('Please select a WASM file first');
                return;
            }

            // Get sudo key from the runtime panel input or keys panel
            const sudoKeyInput = document.getElementById('sudoSecretKey')?.value ||
                                 document.getElementById('sudoSeed')?.value;

            if (!sudoKeyInput) {
                runtimeLog('No sudo key configured', 'error');
                alert('Please enter sudo secret key.\n\nFor dev: use alice, bob, or charlie\nFor production: paste the full 128-byte hex key');
                return;
            }

            const upgradeBtn = document.getElementById('upgradeBtn');
            const chunkedBtn = document.getElementById('chunkedBtn');

            upgradeBtn.disabled = true;
            chunkedBtn.disabled = true;
            upgradeBtn.textContent = 'SUBMITTING...';

            // Show progress bar
            const progressDiv = document.getElementById('upgradeProgress');
            if (progressDiv) progressDiv.style.display = 'block';

            try {
                // Create UpgradeManager instance
                const upgradeManager = new UpgradeManager(RPC);

                runtimeLog('Starting runtime upgrade...', 'info');
                runtimeLog(`WASM file: ${selectedWasm.name}`, 'info');
                runtimeLog(`Force chunked: ${forceChunked}`, 'info');

                const result = await upgradeManager.submitUpgrade(selectedWasm, sudoKeyInput, {
                    forceChunked,
                    onProgress: updateUpgradeProgress,
                    onLog: (msg) => runtimeLog(msg, 'info')
                });

                if (result.success) {
                    runtimeLog(`SUCCESS! Method: ${result.method}`, 'info');
                    runtimeLog(`Transaction: ${result.txHash}`, 'info');

                    upgradeBtn.textContent = 'SUCCESS!';
                    upgradeBtn.style.background = 'var(--accent-success)';

                    // Refresh status after a delay
                    setTimeout(() => {
                        updateStatus();
                        fetchNodeInfo();
                        runtimeLog('Status refreshed - check spec_version', 'info');
                    }, 6000);

                    alert(`Runtime upgrade submitted successfully!\n\nMethod: ${result.method}\nTransaction: ${result.txHash}`);
                }

            } catch (error) {
                runtimeLog(`FAILED: ${error.message}`, 'error');
                console.error('Runtime upgrade error:', error);
                upgradeBtn.textContent = 'FAILED';
                upgradeBtn.style.background = 'var(--accent-danger)';
                alert(`Runtime upgrade FAILED!\n\n${error.message}`);
            } finally {
                upgradeBtn.disabled = false;
                chunkedBtn.disabled = false;

                // Reset button style after delay
                setTimeout(() => {
                    upgradeBtn.style.background = '';
                    upgradeBtn.textContent = 'SUBMIT UPGRADE';
                }, 3000);
            }
        }

        // ============================================
        // KEYSTORE MANAGEMENT V2 - Using KeystoreManager
        // ============================================

        const keystoreManager = new KeystoreManager(RPC);

        async function checkKeystore() {
            keysLog('Checking keystore via RPC...', 'info');

            try {
                // Check pending extrinsics as a connectivity test
                const pending = await keystoreManager.getPendingExtrinsics();
                keysLog(`Node connectivity OK (${pending} pending extrinsics)`, 'info');

                // Try to generate/rotate keys to see what's in the keystore
                // This also serves as a keystore health check
                const keysResult = await keystoreManager.rotateKeys();

                const keysListBox = document.getElementById('keysListBox');
                const noKeysMsg = document.getElementById('noKeysMsg');
                const keysCount = document.getElementById('keysCount');

                if (keysResult.success && keysResult.keys) {
                    keysLog('Session keys found/generated', 'info');
                    keysLog(`Keys: ${keysResult.keys}`, 'info');

                    keysCount.textContent = '1 session key';
                    noKeysMsg.style.display = 'none';

                    // Show session key info with copy button
                    let keyInfo = document.getElementById('sessionKeyInfo');
                    if (!keyInfo) {
                        keyInfo = document.createElement('div');
                        keyInfo.id = 'sessionKeyInfo';
                        keysListBox.appendChild(keyInfo);
                    }
                    keyInfo.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <span class="info-label" style="color: var(--accent-success);">Session Keys</span>
                            <button class="btn btn-secondary btn-sm" onclick="copySessionKey()" style="padding: 2px 8px; font-size: 10px;">COPY</button>
                        </div>
                        <div style="background: var(--bg-void); padding: 8px; border-radius: 4px; word-break: break-all; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--lcars-gold);">
                            ${keysResult.keys}
                        </div>
                    `;

                    // Store for later use
                    window.lastSessionKeys = keysResult.keys;
                } else {
                    keysCount.textContent = '0 keys';
                    noKeysMsg.style.display = 'flex';
                    keysLog('No session keys - use GENERATE NEW KEY', 'warning');
                }

                keysLog('Keystore check complete', 'info');
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
            }
        }

        async function copySessionKey() {
            if (window.lastSessionKeys) {
                try {
                    await navigator.clipboard.writeText(window.lastSessionKeys);
                    keysLog('Session key copied to clipboard!', 'info');
                } catch (e) {
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = window.lastSessionKeys;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    keysLog('Session key copied to clipboard!', 'info');
                }
            } else {
                keysLog('No session key to copy', 'error');
            }
        }

        async function generateKey() {
            keysLog('Generating new session keys via RPC...', 'info');

            try {
                const result = await keystoreManager.rotateKeys();

                if (result.success) {
                    keysLog('New session keys generated!', 'info');
                    keysLog(`Session Keys (hex): ${result.keys.substring(0, 40)}...`, 'info');

                    // Try to derive SS58 address from the session keys
                    // Session keys are concatenated public keys - extract first 64 bytes (32 hex chars = Aura key)
                    const hexKeys = result.keys;
                    let ss58Address = null;

                    try {
                        // The session keys contain multiple concatenated keys
                        // For our runtime: Aura (64 bytes) + Grandpa (64 bytes) = 128 bytes total
                        // Extract the first key (Aura) and convert to SS58
                        const firstKey = hexKeys.substring(0, 130); // 0x + 64 bytes = 130 chars
                        ss58Address = hexToSS58(firstKey);

                        if (ss58Address) {
                            setMyAccount(ss58Address);
                            keysLog(`SS58 Address: ${ss58Address}`, 'info');
                            alert(`New session keys generated!\n\nSession Keys (hex):\n${result.keys}\n\nYour SS58 Address (for faucet):\n${ss58Address}\n\nThis address is now shown in the header - click to copy!`);
                        } else {
                            keysLog('Could not derive SS58 address - use a dev account for testing', 'warning');
                            alert(`New session keys generated!\n\nKeys: ${result.keys}\n\nNote: Could not derive SS58 address.\nUse KEYS tab to select a dev account (Alice/Bob/Charlie) for faucet testing.`);
                        }
                    } catch (e) {
                        keysLog(`SS58 derivation error: ${e.message}`, 'warning');
                        alert(`New session keys generated!\n\nKeys: ${result.keys}\n\nThese keys are now in your node's keystore.`);
                    }

                    await checkKeystore();
                } else {
                    keysLog(`Failed: ${result.message}`, 'error');
                    alert(`Failed to generate keys: ${result.message}`);
                }
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
                alert(`Error generating keys: ${error.message}`);
            }
        }

        async function injectKey() {
            const seedInput = document.getElementById('sudoSeed')?.value?.trim();

            if (!seedInput) {
                keysLog('Please enter: alice/bob/charlie, or a hex key (0x...)', 'error');
                return;
            }

            keysLog(`Injecting key for: ${seedInput.substring(0, 40)}...`, 'info');

            try {
                const devAccounts = keystoreManager.getDevAccounts();
                const seedLower = seedInput.toLowerCase();

                let publicKey, suri;

                // Check for dev accounts first
                if (seedLower === 'alice' || seedLower === '//alice') {
                    publicKey = devAccounts.alice.public;
                    suri = '//Alice';
                } else if (seedLower === 'bob' || seedLower === '//bob') {
                    publicKey = devAccounts.bob.seed || '0x' + 'b'.repeat(128);
                    suri = '//Bob';
                } else if (seedLower === 'charlie' || seedLower === '//charlie') {
                    publicKey = devAccounts.charlie.seed || '0x' + 'c'.repeat(128);
                    suri = '//Charlie';
                } else if (seedInput.startsWith('0x') || /^[0-9a-fA-F]+$/.test(seedInput)) {
                    // Handle raw hex keys (SPHINCS+)
                    const validation = keystoreManager.validateSphincsKey(seedInput);

                    if (!validation.valid) {
                        keysLog(`Invalid key format: ${validation.message}`, 'error');
                        return;
                    }

                    const cleanHex = seedInput.replace('0x', '').toLowerCase();

                    if (validation.type === 'secret') {
                        // SPHINCS+ secret key (128 bytes = 256 hex)
                        // Format: [secret_seed(64 bytes) + public_key(64 bytes)]
                        // Extract public key from last 128 hex chars
                        publicKey = '0x' + cleanHex.slice(-128);
                        suri = '0x' + cleanHex; // Full secret key as suri
                        keysLog(`Detected SPHINCS+ secret key (128 bytes)`, 'info');
                        keysLog(`Derived public key: ${publicKey.substring(0, 20)}...`, 'info');
                    } else if (validation.type === 'seed') {
                        // SPHINCS+ seed (48 bytes = 96 hex)
                        suri = '0x' + cleanHex;
                        // For seeds, we need the node to derive the public key
                        // Try rotateKeys approach or prompt user for public key
                        keysLog(`Detected SPHINCS+ seed (48 bytes)`, 'info');
                        keysLog(`Note: Seed injection requires node-side derivation`, 'warn');
                        publicKey = '0x' + cleanHex; // Placeholder - node should derive
                    } else if (validation.type === 'public') {
                        // Public key only - cannot inject without secret!
                        keysLog(`This is a public key (64 bytes). Cannot inject without secret key!`, 'error');
                        keysLog(`For key injection, provide the FULL secret key (128 bytes / 256 hex chars)`, 'error');
                        return;
                    }
                } else {
                    keysLog('Unknown format. Use alice/bob/charlie or hex key (0x...)', 'error');
                    keysLog('Secret key: 256 hex chars (128 bytes)', 'info');
                    keysLog('Seed: 96 hex chars (48 bytes)', 'info');
                    return;
                }

                const result = await keystoreManager.insertKey('aura', suri, publicKey);

                if (result.success) {
                    keysLog(`Key injected successfully!`, 'info');
                    keysLog(`Public key: ${publicKey.substring(0, 20)}...`, 'info');
                    await checkKeystore();
                } else {
                    keysLog(`Injection failed: ${result.message}`, 'error');
                }
            } catch (error) {
                keysLog(`Error: ${error.message}`, 'error');
            }
        }

        // ============================================
        // GOVERNANCE V2 - Using GovernanceManager
        // ============================================

        const govManager = new GovernanceManager(RPC);

        async function refreshGovernanceStats() {
            try {
                const stats = await govManager.getStats();
                document.getElementById('activeProposals').textContent = stats.active_proposals || 0;
                document.getElementById('votingPeriod').textContent = `${stats.voting_period || 10} blocks`;

                const proposals = await govManager.getProposals();
                const proposalsList = document.getElementById('proposalsList');

                if (proposals && proposals.length > 0) {
                    proposalsList.innerHTML = proposals.map(p => `
                        <div class="info-row">
                            <span class="info-label">Proposal #${p.id}</span>
                            <span class="info-value">${p.proposed?.substring(0, 20)}... (${p.votes_for}/${p.votes_against})</span>
                        </div>
                    `).join('');
                } else {
                    proposalsList.innerHTML = '<div class="info-row"><span class="info-label">No active proposals</span></div>';
                }

                const validators = await govManager.getValidatorSet();
                document.getElementById('validatorCount').textContent = validators?.length || 0;

            } catch (error) {
                console.error('Governance stats error:', error);
            }
        }

        async function proposeValidator() {
            const validatorId = document.getElementById('proposeValidatorAccount')?.value?.trim();
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect; // Fall back to dev account name

            if (!validatorId) {
                alert('Please enter a validator account ID (32-byte hex with 0x prefix)');
                return;
            }

            govLog('Submitting validator proposal...', 'info');
            govLog(`Validator: ${validatorId.substring(0, 20)}...`, 'info');
            govLog(`Signer: ${signerSelect}`, 'info');

            try {
                const result = await govManager.proposeValidator(validatorId, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Proposal submitted! TX: ${result.txHash}`, 'info');
                    alert(`Validator proposal submitted!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Proposal failed: ${error.message}`, 'error');
                alert(`Failed to submit proposal:\n${error.message}`);
            }
        }

        // Governance console helper
        function govLog(message, type = 'info') {
            const terminal = document.getElementById('govTerminal');
            if (!terminal) return;
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearGovConsole() {
            const terminal = document.getElementById('govTerminal');
            if (terminal) terminal.innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function voteOnProposal(proposalId, approve) {
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect;

            govLog(`Voting ${approve ? 'YES' : 'NO'} on proposal #${proposalId}...`, 'info');

            try {
                const result = await govManager.vote(proposalId, approve, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Vote submitted! TX: ${result.txHash}`, 'info');
                    alert(`Vote submitted!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Vote failed: ${error.message}`, 'error');
                alert(`Failed to vote:\n${error.message}`);
            }
        }

        async function finalizeProposal(proposalId) {
            const signerSelect = document.getElementById('proposeSigner')?.value || 'alice';
            const sudoKey = document.getElementById('sudoSecretKey')?.value?.trim() ||
                           document.getElementById('sudoSeed')?.value?.trim() ||
                           signerSelect;

            govLog(`Finalizing proposal #${proposalId}...`, 'info');

            try {
                const result = await govManager.finalizeProposal(proposalId, sudoKey, {
                    onLog: (msg) => govLog(msg, 'info')
                });

                if (result.success) {
                    govLog(`Finalization submitted! TX: ${result.txHash}`, 'info');
                    alert(`Proposal finalized!\n\nTransaction: ${result.txHash}`);
                    await refreshGovernanceStats();
                }
            } catch (error) {
                govLog(`Finalization failed: ${error.message}`, 'error');
                alert(`Failed to finalize:\n${error.message}`);
            }
        }

        // Alias for UI button
        async function refreshProposals() {
            govLog('Refreshing governance data...', 'info');
            await refreshGovernanceStats();
            govLog('Refresh complete', 'info');
        }

        // Keystore source toggle
        function onKeystoreSourceChange() {
            const source = document.getElementById('keystoreSource').value;
            document.getElementById('keystorePathBox').style.display = source === 'local' ? 'block' : 'none';
            document.getElementById('hsmBox').style.display = source === 'hsm' ? 'block' : 'none';
            log(`Key storage: ${source === 'hsm' ? 'Hardware Security Module' : 'Local Keystore'}`, 'info');
        }

        // Entropy source toggle
        function onEntropySourceChange() {
            const source = document.getElementById('entropySource').value;
            log(`Entropy source: ${source}`, 'info');
        }

        // Crypto4A QRNG functions
        async function testCrypto4aRng() {
            const endpoint = document.getElementById('crypto4aEndpoint').value;
            log(`Testing Crypto4A QRNG at ${endpoint}...`, 'info');

            try {
                const res = await fetch(`${endpoint}?size=8`);
                if (res.ok) {
                    const data = await res.arrayBuffer();
                    const hex = Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('crypto4aStatus').textContent = 'Online';
                    document.getElementById('crypto4aStatus').style.color = 'var(--accent-success)';
                    document.getElementById('crypto4aEntropy').textContent = '0x' + hex;
                    log(`Crypto4A QRNG online - received: 0x${hex}`, 'info');
                } else {
                    throw new Error(`HTTP ${res.status}`);
                }
            } catch (e) {
                document.getElementById('crypto4aStatus').textContent = 'Offline';
                document.getElementById('crypto4aStatus').style.color = 'var(--accent-danger)';
                log(`Crypto4A QRNG error: ${e.message}`, 'error');
            }
        }

        async function fetchCrypto4aEntropy(bytes) {
            const endpoint = document.getElementById('crypto4aEndpoint').value;
            log(`Fetching ${bytes} bytes from Crypto4A QRNG...`, 'info');

            try {
                const res = await fetch(`${endpoint}?size=${bytes}`);
                if (res.ok) {
                    const data = await res.arrayBuffer();
                    const hex = Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join('');
                    document.getElementById('crypto4aEntropy').textContent = '0x' + hex.substring(0, 48) + (hex.length > 48 ? '...' : '');
                    log(`Received ${bytes} bytes: 0x${hex.substring(0, 32)}...`, 'info');
                } else {
                    throw new Error(`HTTP ${res.status}`);
                }
            } catch (e) {
                log(`Failed to fetch entropy: ${e.message}`, 'error');
            }
        }

        // Keys console helper
        function keysLog(message, type = 'info') {
            const terminal = document.getElementById('keysTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearKeysConsole() {
            document.getElementById('keysTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        // Clipboard helper
        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'COPIED!';
                button.style.background = 'var(--accent-success)';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 1500);
                keysLog('Public key copied to clipboard', 'info');
            } catch (e) {
                keysLog('Failed to copy: ' + e.message, 'error');
            }
        }

        // Display keys in the keys list
        function displayKeys(keys) {
            const container = document.getElementById('keysListBox');
            const countEl = document.getElementById('keysCount');
            const noKeysMsg = document.getElementById('noKeysMsg');

            countEl.textContent = `${keys.length} key${keys.length !== 1 ? 's' : ''}`;

            if (keys.length === 0) {
                noKeysMsg.style.display = 'flex';
                // Remove any existing key items
                container.querySelectorAll('.key-item').forEach(el => el.remove());
                return;
            }

            noKeysMsg.style.display = 'none';

            // Remove existing key items
            container.querySelectorAll('.key-item').forEach(el => el.remove());

            // Add each key
            keys.forEach((key, index) => {
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                keyItem.style.cssText = 'background: var(--bg-surface); border-radius: 8px; padding: 12px; margin-bottom: 12px;';

                const shortKey = key.public_key.substring(0, 24) + '...' + key.public_key.slice(-8);

                keyItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 11px;">KEY ${index + 1} - ${key.key_type || 'aura'}</span>
                        <span style="color: var(--text-muted); font-size: 10px;">${key.algorithm || 'SPHINCS+-256s'}</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <code style="flex: 1; background: var(--bg-void); padding: 8px; border-radius: 4px; font-size: 10px; color: var(--accent-success); word-break: break-all; font-family: 'JetBrains Mono', monospace;">${shortKey}</code>
                        <button class="btn btn-secondary btn-sm" onclick="copyToClipboard('${key.public_key}', this)" style="white-space: nowrap;">COPY</button>
                    </div>
                    <div style="margin-top: 8px; font-size: 10px; color: var(--text-muted);">
                        Full key saved at: <span style="color: var(--lcars-blue-light);">${key.path || 'keystore'}</span>
                    </div>
                `;

                container.appendChild(keyItem);
            });
        }

        // Legacy keys functions removed - now using KeystoreManager (defined earlier)
        // See checkKeystore(), generateKey(), injectKey() at ~lines 2061-2167

        // ===========================================
        // TRANSFER FUNCTIONS
        // ===========================================

        // Pallet index for Balances (from runtime construct_runtime!)
        const BALANCES_INDEX = 5;

        // Production validator SS58 addresses (genesis accounts)
        const DEV_ADDRESSES = {
            alice: '5GDGYeQveNfCqfjqpiCB8pPoLb42yqnsgmzjLHZmWkqh1ToY',
            bob: '5CT4mnE7KMeGG6MqSyVLFa7CLkyRtb8FHCafW4zUHKYh4cg6',
            charlie: '5FMbuNfb3gYxLHZX7VXhBEMy3mcuUHvb6hFyQCVrFwr4Fjb5'
        };

        function transferLog(message, type = 'info') {
            const terminal = document.getElementById('transferTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearTransferConsole() {
            document.getElementById('transferTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        function fillRecipient(account) {
            const addr = DEV_ADDRESSES[account];
            if (addr) {
                document.getElementById('transferRecipient').value = addr;
                transferLog(`Filled recipient: ${account} (${addr.substring(0, 20)}...)`, 'info');
            }
        }

        // Get the secret key from input, normalizing format
        function getTransferSecretKey() {
            let key = document.getElementById('transferSecretKey').value.trim();
            // Remove 0x prefix if present
            if (key.startsWith('0x')) key = key.substring(2);
            return key;
        }

        // Derive address from secret key using gateway RPC
        async function updateSenderFromKey() {
            const secretKey = getTransferSecretKey();
            const keyStatusEl = document.getElementById('keyStatus');

            if (!secretKey) {
                document.getElementById('transferSenderAddress').value = '';
                document.getElementById('senderBalance').textContent = '---';
                keyStatusEl.textContent = 'No Key';
                keyStatusEl.style.color = '';
                return;
            }

            // Validate key length (48 bytes = 96 hex chars, or 128 bytes = 256 hex chars)
            if (secretKey.length !== 96 && secretKey.length !== 256) {
                transferLog(`Invalid key length: ${secretKey.length} hex chars. Expected 96 (seed) or 256 (full key)`, 'error');
                keyStatusEl.textContent = 'Invalid';
                keyStatusEl.style.color = 'var(--accent-danger)';
                return;
            }

            // Update status based on key type
            if (secretKey.length === 96) {
                keyStatusEl.textContent = '48B Seed';
            } else {
                keyStatusEl.textContent = '128B Key';
            }
            keyStatusEl.style.color = 'var(--accent-success)';

            transferLog('Deriving address from key...', 'info');

            try {
                // Use gateway to derive address from key
                const result = await rpc('gateway_deriveAddress', ['0x' + secretKey]);
                if (result) {
                    document.getElementById('transferSenderAddress').value = result;
                    transferLog(`Address: ${result.substring(0, 20)}...`, 'info');
                    // Now fetch balance for this address
                    await updateSenderBalance();
                }
            } catch (e) {
                // If gateway_deriveAddress doesn't exist, show message
                transferLog(`Address derivation: ${e.message}`, 'warning');
                transferLog('Enter address manually or check balance after first tx', 'info');
                document.getElementById('transferSenderAddress').value = 'Unable to derive - submit tx to see address';
            }
        }

        async function updateSenderBalance() {
            const address = document.getElementById('transferSenderAddress').value.trim();

            if (!address || address.includes('Unable') || !address.startsWith('5')) {
                document.getElementById('senderBalance').textContent = '---';
                return;
            }

            try {
                transferLog(`Fetching balance for ${address.substring(0, 15)}...`, 'info');

                // Use gateway_balance RPC
                const balance = await rpc('gateway_balance', [address]);
                if (balance !== undefined && balance !== null) {
                    const balanceBigInt = BigInt(balance);
                    const qmhy = Number(balanceBigInt / BigInt(1_000_000_000_000_000_000));
                    document.getElementById('senderBalance').textContent = `${qmhy.toLocaleString()} QMHY`;
                    transferLog(`Balance: ${qmhy.toLocaleString()} QMHY`, 'info');

                    // Show warning if balance is 0
                    const warningDiv = document.getElementById('devAccountWarning');
                    if (balanceBigInt === 0n) {
                        warningDiv.style.display = 'block';
                        transferLog('Account shows 0 balance - use faucet to get tokens', 'warning');
                    } else {
                        warningDiv.style.display = 'none';
                    }
                }
            } catch (e) {
                transferLog(`Balance query failed: ${e.message}`, 'error');
                document.getElementById('senderBalance').textContent = '---';
            }
        }

        async function sendTransfer() {
            const secretKey = getTransferSecretKey();
            const recipient = document.getElementById('transferRecipient').value.trim();
            const amountStr = document.getElementById('transferAmount').value;

            if (!secretKey) {
                transferLog('Please enter your secret key', 'error');
                return;
            }

            if (secretKey.length !== 96 && secretKey.length !== 256) {
                transferLog(`Invalid key length. Expected 96 (seed) or 256 (full key) hex chars`, 'error');
                return;
            }

            if (!recipient) {
                transferLog('Please enter a recipient address', 'error');
                return;
            }

            if (!recipient.startsWith('5')) {
                transferLog('Invalid recipient address. Must start with 5 (SS58)', 'error');
                return;
            }

            if (!amountStr || parseFloat(amountStr) <= 0) {
                transferLog('Please enter a valid amount', 'error');
                return;
            }

            const amount = parseFloat(amountStr);

            transferLog(`Initiating transfer of ${amount} QMHY...`, 'warning');
            transferLog(`To: ${recipient.substring(0, 20)}...`, 'info');

            try {
                // Get genesis hash
                const genesisHash = await rpc('gateway_genesisHash', []);
                transferLog(`Genesis: ${genesisHash.substring(0, 20)}...`, 'info');

                // Convert amount to smallest units (18 decimals)
                const amountPlanck = BigInt(Math.floor(amount * 1_000_000_000_000_000_000));

                // Build transaction request - gateway will derive address from key
                const txRequest = {
                    to: recipient,
                    amount: amountPlanck.toString(),
                    genesisHash: genesisHash,
                    secretKey: '0x' + secretKey
                };

                transferLog('Submitting SPHINCS+ signed transaction...', 'warning');

                // Submit via gateway_submit
                const result = await rpc('gateway_submit', [txRequest]);

                if (result && result.hash) {
                    transferLog(`âœ“ Transfer submitted!`, 'info');
                    transferLog(`TX Hash: ${result.hash}`, 'info');
                    if (result.from) {
                        document.getElementById('transferSenderAddress').value = result.from;
                        transferLog(`From: ${result.from.substring(0, 20)}...`, 'info');
                    }
                    if (result.status) {
                        transferLog(`Status: ${result.status}`, 'info');
                    }

                    // Refresh balance after block confirmation (~6 seconds)
                    transferLog('Waiting for block confirmation...', 'warning');
                    setTimeout(() => {
                        updateSenderBalance();
                        transferLog('Balance updated', 'info');
                    }, 6000);
                } else {
                    transferLog('Transfer submitted but no hash returned', 'warning');
                    transferLog(JSON.stringify(result), 'info');
                }
            } catch (e) {
                transferLog(`Error: ${e.message}`, 'error');
                if (e.message.includes('BadProof')) {
                    transferLog('Hint: Invalid key or signature mismatch', 'warning');
                } else if (e.message.includes('nonce')) {
                    transferLog('Hint: Nonce may be stale. Wait for previous tx to confirm.', 'warning');
                } else if (e.message.includes('funds')) {
                    transferLog('Hint: Insufficient balance for transfer + fees', 'warning');
                }
            }
        }

        // ===========================================
        // FAUCET FUNCTIONS
        // ===========================================

        // Use proxied faucet to avoid mixed content (HTTPS->HTTP) issues
        const FAUCET_URL = '/faucet';
        const FAUCET_DRIP_AMOUNT = 100; // QMHY
        const FAUCET_RATE_LIMIT_MS = 60000; // 1 minute
        let lastDripTime = {};
        let totalDripCount = 0;
        let faucetOnline = false;

        function faucetLog(message, type = 'info') {
            const terminal = document.getElementById('faucetTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearFaucetConsole() {
            document.getElementById('faucetTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        function updateFaucetStatus(online, message = '') {
            const statusPill = document.getElementById('faucetServiceStatus');
            const statusText = document.getElementById('faucetServiceStatusText');
            const healthDisplay = document.getElementById('faucetServiceHealth');
            const warningDiv = document.getElementById('faucetOfflineWarning');
            const requestBtn = document.getElementById('requestDripBtn');

            faucetOnline = online;

            if (online) {
                statusPill.className = 'status-pill online';
                statusText.textContent = 'ONLINE';
                healthDisplay.textContent = message || 'Ready';
                healthDisplay.className = 'stat-value green';
                warningDiv.style.display = 'none';
                requestBtn.disabled = false;
                requestBtn.style.opacity = '1';
            } else {
                statusPill.className = 'status-pill offline';
                statusText.textContent = 'OFFLINE';
                healthDisplay.textContent = 'Unavailable';
                healthDisplay.className = 'stat-value';
                healthDisplay.style.color = 'var(--accent-danger)';
                warningDiv.style.display = 'block';
                requestBtn.disabled = true;
                requestBtn.style.opacity = '0.5';
            }
        }

        async function checkFaucetService() {
            faucetLog('Checking faucet service status...', 'info');
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(`${FAUCET_URL}/health`, {
                    method: 'GET',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    updateFaucetStatus(true, `Block: ${data.block_height || 'N/A'}`);
                    faucetLog(`Faucet online - ${data.validators_online || 0} validators`, 'info');
                } else {
                    updateFaucetStatus(false);
                    faucetLog(`Faucet returned error: ${response.status}`, 'error');
                }
            } catch (e) {
                updateFaucetStatus(false);
                if (e.name === 'AbortError') {
                    faucetLog('Faucet service timeout - service may be down', 'error');
                } else {
                    faucetLog(`Faucet check failed: ${e.message}`, 'error');
                }
            }
        }

        async function requestDrip() {
            const recipient = document.getElementById('faucetRecipient').value.trim();

            if (!recipient) {
                faucetLog('Please enter a recipient address', 'error');
                return;
            }

            // Validate SS58 format (starts with 5, ~48 chars)
            if (!recipient.startsWith('5') || recipient.length < 45 || recipient.length > 50) {
                faucetLog('Invalid address format. Must be SS58 (starts with 5)', 'error');
                return;
            }

            // Check rate limit
            const now = Date.now();
            if (lastDripTime[recipient] && (now - lastDripTime[recipient]) < FAUCET_RATE_LIMIT_MS) {
                const waitSecs = Math.ceil((FAUCET_RATE_LIMIT_MS - (now - lastDripTime[recipient])) / 1000);
                faucetLog(`Rate limited. Wait ${waitSecs} seconds.`, 'error');
                return;
            }

            faucetLog(`Requesting ${FAUCET_DRIP_AMOUNT} QMHY for ${recipient.substring(0, 15)}...`, 'warning');

            try {
                const response = await fetch(`${FAUCET_URL}/drip`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: recipient })
                });

                const result = await response.json();

                if (result.success) {
                    faucetLog(`Drip sent! TX: ${result.tx_hash || 'pending'}`, 'info');
                    faucetLog(`Amount: ${result.amount || '100 QMHY'}`, 'info');

                    // Update rate limit and counter
                    lastDripTime[recipient] = now;
                    totalDripCount++;
                    document.getElementById('totalDrips').textContent = totalDripCount;
                } else {
                    faucetLog(`Drip failed: ${result.error || result.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                faucetLog(`Error: ${e.message}`, 'error');
                faucetLog('Faucet service may be offline. Check status.', 'warning');
                updateFaucetStatus(false);
            }
        }

        async function generateAccount() {
            faucetLog('Generating new SPHINCS+ account...', 'warning');

            // Generate random 48-byte seed
            const seedArray = new Uint8Array(48);
            crypto.getRandomValues(seedArray);
            const seedHex = Array.from(seedArray).map(b => b.toString(16).padStart(2, '0')).join('');

            // For a proper address we'd need to derive the SPHINCS+ public key and hash it
            // This is a simplified version - the real address would come from the node
            // For demo purposes, show the seed and note that proper derivation is needed

            const resultDiv = document.getElementById('generatedAccount');
            resultDiv.innerHTML = `
                <div style="background: var(--bg-elevated); padding: 12px; border-radius: 8px; margin-top: 12px;">
                    <div style="margin-bottom: 8px;">
                        <span style="color: var(--text-muted); font-size: 11px;">SEED (SAVE SECURELY!)</span>
                        <div style="font-family: 'JetBrains Mono', monospace; font-size: 11px; word-break: break-all; color: var(--accent-warning); margin-top: 4px;">
                            ${seedHex}
                        </div>
                    </div>
                    <div style="color: var(--accent-danger); font-size: 11px; margin-top: 8px;">
                        âš  Use this seed with gateway_submit to derive your address on first transaction
                    </div>
                    <button class="btn btn-secondary btn-sm" style="margin-top: 8px;" onclick="navigator.clipboard.writeText('${seedHex}')">COPY SEED</button>
                </div>
            `;

            faucetLog('Generated 48-byte SPHINCS+ seed', 'info');
            faucetLog('Use seed with first transaction to derive address', 'info');
        }

        // ===========================================
        // GOVERNANCE FUNCTIONS
        // ===========================================

        // Dev account seeds (from validator-governance-cli.py)
        const DEV_ACCOUNTS = {
            alice: '2eb5fca9ecb08243d333e38adbc99a786edea20f8f88c51b5703754eef4d7a66183e03c1de99dc133c29c5cde6a984f5',
            bob: '034a9b6570680a960ff781fec37012c355cbf698e26788b6f3b351daec75beea101f9c3b8b07fefa1d84d8b48ea02f1e',
            charlie: 'b2e5b1dd89b389f61b108bff36755bd0b5208aac741233e538a464dbd841b5bf68cc36bde662e8fde70fd41cdd605766'
        };

        // Pallet indices (from runtime)
        const VALIDATOR_GOVERNANCE_INDEX = 41;
        const VALIDATOR_REWARDS_INDEX = 40;

        function govLog(message, type = 'info') {
            const terminal = document.getElementById('govTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearGovConsole() {
            document.getElementById('govTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function proposeValidator() {
            const account = document.getElementById('proposeValidatorAccount').value.trim();
            const signer = document.getElementById('proposeSigner').value;

            if (!account || !account.startsWith('0x')) {
                govLog('Please enter a valid validator account (0x...)', 'error');
                return;
            }

            govLog(`Proposing validator: ${account.substring(0, 20)}...`, 'info');
            govLog(`Signer: ${signer}`, 'info');

            try {
                // Call custom RPC for quantum-signed extrinsic
                const callData = account.replace('0x', '');
                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '00' + callData,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    // Handle both old string format and new JSON object format
                    const txHash = result.hash || result;
                    govLog(`Proposal submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                    if (result.signer) govLog(`Signer: ${result.signer.substring(0, 20)}...`, 'info');
                    govLog('Wait for next block to see proposal in list.', 'info');
                    setTimeout(refreshProposals, 6000);
                } else {
                    govLog('Transaction failed - check node connection', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        async function refreshProposals() {
            govLog('Refreshing proposals...', 'info');

            try {
                // Query NextProposalId to get count
                // Storage: twox128("ValidatorGovernance") + twox128("NextProposalId")
                const result = await rpc('state_getStorage', ['0x' +
                    '5c41d26de442c8c2bb8a08df2fdc0ab3' + // twox128("ValidatorGovernance")
                    'f485e09e76a76c90df1caaab2dcc87f5'   // twox128("NextProposalId")
                ]);

                if (result) {
                    const nextId = parseInt(result.slice(2), 16);
                    const totalEl = document.getElementById('totalProposals');
                    const activeEl = document.getElementById('activeProposals');
                    if (totalEl) totalEl.textContent = nextId;
                    if (activeEl) activeEl.textContent = nextId;
                    govLog(`Found ${nextId} proposal(s)`, 'info');

                    if (nextId > 0) {
                        displayProposals(nextId);
                    }
                } else {
                    const totalEl = document.getElementById('totalProposals');
                    const activeEl = document.getElementById('activeProposals');
                    if (totalEl) totalEl.textContent = '0';
                    if (activeEl) activeEl.textContent = '0';
                    govLog('No proposals found', 'info');
                }
            } catch (e) {
                govLog(`Error querying proposals: ${e.message}`, 'error');
            }
        }

        async function displayProposals(count) {
            const container = document.getElementById('proposalsList');
            const noMsg = document.getElementById('noProposalsMsg');

            // Clear existing proposals
            container.querySelectorAll('.proposal-item').forEach(el => el.remove());

            if (count === 0) {
                noMsg.style.display = 'flex';
                return;
            }

            noMsg.style.display = 'none';

            // Display proposal cards (simplified - would need full storage queries)
            for (let i = 0; i < count; i++) {
                const item = document.createElement('div');
                item.className = 'proposal-item';
                item.style.cssText = 'background: var(--bg-surface); border-radius: 8px; padding: 16px; margin-bottom: 12px;';

                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <span style="color: var(--lcars-gold); font-family: 'Orbitron', monospace; font-size: 14px;">PROPOSAL #${i}</span>
                        <span style="color: var(--accent-warning); font-size: 12px; padding: 4px 12px; background: rgba(255,183,77,0.1); border-radius: 20px;">ACTIVE</span>
                    </div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 16px;">
                        Proposed validator addition - Click vote to participate
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-success btn-sm" onclick="voteOnProposal(${i}, true)" style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 16px;">ðŸ‘</span> APPROVE
                        </button>
                        <button class="btn btn-danger btn-sm" onclick="voteOnProposal(${i}, false)" style="display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 16px;">ðŸ‘Ž</span> REJECT
                        </button>
                        <button class="btn btn-secondary btn-sm" onclick="finalizeProposal(${i})">FINALIZE</button>
                    </div>
                `;

                container.appendChild(item);
            }
        }

        async function voteOnProposal(proposalId, approve) {
            const signer = document.getElementById('proposeSigner').value;
            govLog(`Voting ${approve ? 'YES' : 'NO'} on proposal #${proposalId}...`, 'info');

            try {
                // Encode: proposal_id (u32 LE) + approve (bool)
                const idBytes = proposalId.toString(16).padStart(8, '0');
                const idLE = idBytes.match(/../g).reverse().join('');
                const approveHex = approve ? '01' : '00';

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '01' + idLE + approveHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    govLog(`Vote submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    govLog('Vote failed - are you a validator?', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        async function finalizeProposal(proposalId) {
            const signer = document.getElementById('proposeSigner').value;
            govLog(`Finalizing proposal #${proposalId}...`, 'info');

            try {
                const idBytes = proposalId.toString(16).padStart(8, '0');
                const idLE = idBytes.match(/../g).reverse().join('');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_GOVERNANCE_INDEX.toString(16).padStart(2, '0') + '02' + idLE,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    govLog(`Finalization submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                    setTimeout(refreshProposals, 6000);
                } else {
                    govLog('Finalization failed - voting period may not be over', 'error');
                }
            } catch (e) {
                govLog(`Error: ${e.message}`, 'error');
            }
        }

        // ===========================================
        // REWARDS FUNCTIONS
        // ===========================================

        function rewardsLog(message, type = 'info') {
            const terminal = document.getElementById('rewardsTerminal');
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            while (terminal.children.length > 50) terminal.removeChild(terminal.firstChild);
        }

        function clearRewardsConsole() {
            document.getElementById('rewardsTerminal').innerHTML = '<div class="terminal-line info">Console cleared</div>';
        }

        async function refreshRewards() {
            rewardsLog('Refreshing rewards data...', 'info');

            try {
                // First try the new RPC endpoint
                const rewardsInfo = await rpc('quantumharmony_getRewardsInfo', [
                    document.getElementById('settingsController')?.value || '0x0000000000000000000000000000000000000000'
                ]);

                if (rewardsInfo) {
                    document.getElementById('pendingRewards').textContent = rewardsInfo.pending_rewards || '0 QMHY';
                    document.getElementById('totalStaked').textContent = rewardsInfo.total_staked || '0 QMHY';
                    document.getElementById('certLevel').textContent = rewardsInfo.certification_level || 'Uncertified';
                    document.getElementById('rewardMultiplier').textContent = rewardsInfo.reward_multiplier || '70%';
                    rewardsLog('Rewards data refreshed', 'info');
                }
            } catch (e) {
                // Fallback to runtime version check
                try {
                    const result = await rpc('state_getRuntimeVersion');
                    if (result && result.specVersion >= 17) {
                        rewardsLog(`Runtime v${result.specVersion} - Enhanced rewards available`, 'info');
                        document.getElementById('certLevel').textContent = 'Uncertified';
                        document.getElementById('rewardMultiplier').textContent = '70%';
                    } else if (result) {
                        rewardsLog(`Runtime v${result.specVersion} - Basic rewards`, 'info');
                    }
                } catch (e2) {
                    rewardsLog(`Error: ${e2.message}`, 'error');
                }
            }
        }

        async function stakeTokens() {
            const amount = document.getElementById('stakeAmount').value;
            const signer = document.getElementById('proposeSigner')?.value || 'alice';

            if (!amount || amount <= 0) {
                rewardsLog('Please enter a valid stake amount', 'error');
                return;
            }

            rewardsLog(`Staking ${amount} QMHY...`, 'warning');

            try {
                // Encode stake call: ValidatorRewards::stake(amount)
                // Pallet index 40, call index 00
                const amountBigInt = BigInt(amount) * BigInt(1_000_000_000_000); // Convert to planck
                const amountHex = amountBigInt.toString(16).padStart(32, '0');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '00' + amountHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Stake submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Stake failed - check node connection', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function requestUnstake() {
            const amount = document.getElementById('unstakeAmount').value;
            const signer = document.getElementById('proposeSigner')?.value || 'alice';

            if (!amount || amount <= 0) {
                rewardsLog('Please enter a valid unstake amount', 'error');
                return;
            }

            rewardsLog(`Requesting unstake of ${amount} QMHY...`, 'warning');
            rewardsLog('100 block cooldown will apply', 'info');

            try {
                // Encode unstake call: ValidatorRewards::request_unstake(amount)
                // Pallet index 40, call index 01
                const amountBigInt = BigInt(amount) * BigInt(1_000_000_000_000);
                const amountHex = amountBigInt.toString(16).padStart(32, '0');

                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '01' + amountHex,
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Unstake request submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Unstake request failed', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function claimRewards() {
            const signer = document.getElementById('proposeSigner')?.value || 'alice';
            rewardsLog('Claiming pending rewards...', 'warning');
            rewardsLog('Rate limit: 1 claim per 10 blocks', 'info');

            try {
                // Encode claim call: ValidatorRewards::claim_rewards()
                // Pallet index 40, call index 02 (no arguments)
                const result = await rpc('quantumharmony_submitSignedExtrinsic', [
                    '0x' + VALIDATOR_REWARDS_INDEX.toString(16).padStart(2, '0') + '02',
                    '0x' + DEV_ACCOUNTS[signer]
                ]);

                if (result) {
                    const txHash = result.hash || result;
                    rewardsLog(`Claim submitted! TX: ${txHash.substring(0, 30)}...`, 'info');
                } else {
                    rewardsLog('Claim failed', 'error');
                }
            } catch (e) {
                rewardsLog(`Error: ${e.message}`, 'error');
            }
        }

        async function submitUptimeProof() {
            rewardsLog('Submitting uptime proof...', 'info');
            // This would be called automatically by the node in production
            rewardsLog('Uptime proofs are submitted automatically by validator nodes', 'info');
        }

        // ===========================================
        // NETWORK MESH VISUALIZATION
        // ===========================================

        // Known validator data (bootstrap nodes + approved validators)
        const KNOWN_VALIDATORS = {
            '12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp': { name: 'Alice', ip: '51.79.26.123', location: 'Montreal, Canada', provider: 'OVH', color: '#ff9966', tier: 1 },
            '12D3KooWHdiAxVd8uMQR1hGWXccidmfCwLqcMpGwR6QcTP6QRMuD': { name: 'Bob', ip: '51.79.26.168', location: 'Beauharnois, Canada', provider: 'OVH', color: '#66ccff', tier: 1 },
            '12D3KooWSCufgHzV4fCwRijfH2k3abrpAJxTKxEvN1FDuRXA2U9x': { name: 'Charlie', ip: '209.38.225.4', location: 'Frankfurt, Germany', provider: 'DigitalOcean', color: '#99ff99', tier: 1 },
            '12D3KooWAZF2rTG2mVUBkaUAhdJ71EDgMDvCU1VZiPTpJVj7cVi1': { name: 'Edwin', ip: null, location: 'Africa', provider: 'Community', color: '#ff66cc', tier: 2 }
        };

        // Dynamic colors for discovered peers
        const PEER_COLORS = ['#ff66cc', '#66ffcc', '#cc66ff', '#ffcc66', '#66ccff', '#ccff66'];
        let peerColorIndex = 0;

        // Local node (you)
        const LOCAL_NODE = { name: 'You', ip: 'localhost', peerId: 'local', location: 'Local', provider: 'Docker', color: '#ffcc00', tier: 2, role: 'Your Node' };

        let networkAnimationFrame = null;
        let discoveredPeers = []; // All discovered peers with their info
        let geoCache = {}; // Cache for IP geolocation results

        // Geolocation lookup - non-blocking, returns cached or default immediately
        async function geolocateIP(ip) {
            if (geoCache[ip]) return geoCache[ip];
            if (!ip || ip === 'localhost' || ip.startsWith('127.') || ip.startsWith('192.168.') || ip.startsWith('10.')) {
                return { city: 'Local', country: 'Network', isp: 'Private' };
            }
            // Return default immediately, fetch in background
            const defaultGeo = { city: 'Resolving...', country: '', isp: '' };
            geoCache[ip] = defaultGeo;

            // Background fetch (non-blocking)
            fetch(`https://ipapi.co/${ip}/json/`)
                .then(res => res.json())
                .then(data => {
                    if (data && data.city) {
                        geoCache[ip] = { city: data.city, country: data.country_name || '', isp: data.org || '' };
                    }
                })
                .catch(() => {
                    geoCache[ip] = { city: 'Unknown', country: '', isp: '' };
                });

            return defaultGeo;
        }

        // Extract IP from multiaddr (e.g., /ip4/51.79.26.123/tcp/30333)
        function extractIPFromMultiaddr(addr) {
            if (!addr) return null;
            const match = addr.match(/\/ip4\/(\d+\.\d+\.\d+\.\d+)/);
            return match ? match[1] : null;
        }

        // Draw toroidal mesh network visualization
        function drawNetworkMesh() {
            const canvas = document.getElementById('networkCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, width, height);

            // Draw grid representing toroidal wrap-around
            ctx.strokeStyle = 'rgba(255, 153, 102, 0.1)';
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let y = 0; y <= height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Vertical grid lines
            for (let x = 0; x <= width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // Build node list: LOCAL_NODE + all discovered peers
            const allNodes = [LOCAL_NODE, ...discoveredPeers];
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() / 3000;

            // Position nodes in a circle
            const nodePositions = allNodes.map((node, i) => {
                const angle = (i / Math.max(allNodes.length, 1)) * Math.PI * 2 + time * 0.15;
                const baseRadius = Math.min(width, height) * 0.32;
                const radius = baseRadius + Math.sin(time + i) * 8;
                // Local node (you) in center
                const isLocal = node.peerId === 'local';
                return {
                    x: isLocal ? centerX : centerX + Math.cos(angle) * radius,
                    y: isLocal ? centerY : centerY + Math.sin(angle) * radius * 0.6,
                    node: node,
                    isLocal: isLocal
                };
            });

            // Draw connections from YOU to peers
            // Solid lines for direct connections, dotted for known but not connected
            ctx.lineWidth = 2;
            const localPos = nodePositions.find(p => p.isLocal);
            let directLinkCount = 0;

            if (localPos) {
                nodePositions.forEach((pos, i) => {
                    if (pos.isLocal) return;

                    const isDirectConnection = pos.node.directConnection === true;
                    if (isDirectConnection) directLinkCount++;

                    // Connection line style based on connection status
                    const gradient = ctx.createLinearGradient(localPos.x, localPos.y, pos.x, pos.y);
                    if (isDirectConnection) {
                        // Solid bright line for direct connections
                        gradient.addColorStop(0, LOCAL_NODE.color + 'cc');
                        gradient.addColorStop(1, pos.node.color + 'cc');
                        ctx.lineWidth = 3;
                        ctx.setLineDash([]);
                    } else {
                        // Dotted dim line for known but not connected
                        gradient.addColorStop(0, LOCAL_NODE.color + '40');
                        gradient.addColorStop(1, pos.node.color + '40');
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                    }
                    ctx.strokeStyle = gradient;

                    ctx.beginPath();
                    ctx.moveTo(localPos.x, localPos.y);
                    const midX = (localPos.x + pos.x) / 2;
                    const midY = (localPos.y + pos.y) / 2 - 15;
                    ctx.quadraticCurveTo(midX, midY, pos.x, pos.y);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset

                    // Animated data packet only for direct connections
                    if (isDirectConnection) {
                        const packetPos = (time * 1.5 + i * 0.3) % 1;
                        const px = localPos.x + (pos.x - localPos.x) * packetPos;
                        const py = localPos.y + (pos.y - localPos.y) * packetPos - Math.sin(packetPos * Math.PI) * 15;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            // Draw nodes
            nodePositions.forEach((pos, i) => {
                const nodeSize = pos.isLocal ? 20 : 15;
                const node = pos.node;

                // Outer glow
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 35);
                gradient.addColorStop(0, node.color + '60');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 35, 0, Math.PI * 2);
                ctx.fill();

                // Node circle
                ctx.fillStyle = node.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                ctx.fill();

                // Node border
                ctx.strokeStyle = pos.isLocal ? '#ffcc00' : '#ffffff';
                ctx.lineWidth = pos.isLocal ? 3 : 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#ffffff';
                ctx.font = pos.isLocal ? 'bold 13px Orbitron, monospace' : '11px Orbitron, monospace';
                ctx.textAlign = 'center';
                ctx.fillText(node.name, pos.x, pos.y + nodeSize + 18);

                // Location label
                ctx.fillStyle = '#888888';
                ctx.font = '9px JetBrains Mono, monospace';
                const locationText = node.location ? node.location.split(',')[0] : '';
                ctx.fillText(locationText, pos.x, pos.y + nodeSize + 30);
            });

            // Title
            ctx.fillStyle = '#ff9966';
            ctx.font = '14px Orbitron, monospace';
            ctx.textAlign = 'left';
            ctx.fillText('NETWORK MESH', 10, 25);

            // Show validators in network (discovered peers are validators, not direct connections)
            const validatorCount = discoveredPeers.length;
            ctx.fillStyle = validatorCount >= 2 ? '#66ff66' : (validatorCount >= 1 ? '#ffcc00' : '#ff4444');
            ctx.font = '11px JetBrains Mono, monospace';
            ctx.textAlign = 'right';
            ctx.fillText(`${validatorCount} VALIDATORS`, width - 10, 25);

            // Continue animation
            networkAnimationFrame = requestAnimationFrame(drawNetworkMesh);
        }

        // Populate node cards dynamically from discovered peers
        function updateValidatorNodes() {
            const container = document.getElementById('validatorNodes');
            if (!container) return;

            const renderNodeCard = (node, isLocal = false) => {
                const statusColor = 'var(--accent-success)';
                return `
                <div style="background: var(--bg-surface); border-radius: var(--radius-md); padding: var(--space-3); border-left: 3px solid ${node.color};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="color: ${node.color}; font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 600;">${node.name}</span>
                        <span class="status-indicator" style="width: 8px; height: 8px; border-radius: 50%; background: ${statusColor}; box-shadow: 0 0 6px ${statusColor};"></span>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">
                        ðŸ“ ${node.location || 'Unknown'}
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">
                        ðŸŒ ${node.ip || 'Unknown'}
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px;">
                        <span style="color: var(--lcars-blue-light);">Provider:</span> ${node.provider || 'Unknown'}
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--bg-elevated);">
                        <span style="color: ${node.tier === 1 ? 'var(--accent-success)' : 'var(--lcars-gold)'};">Tier ${node.tier || 2}</span>
                        <span style="color: ${isLocal ? 'var(--lcars-gold)' : 'var(--text-muted)'};">${isLocal ? 'Your Node' : (node.role || 'Peer')}</span>
                    </div>
                </div>
            `};

            // Render: Your node first, then all discovered peers
            const yourCard = renderNodeCard(LOCAL_NODE, true);
            const peerCards = discoveredPeers.map(peer => renderNodeCard(peer)).join('');
            container.innerHTML = yourCard + peerCards;
        }

        // Production validator RPC endpoints for network-wide discovery
        // Use proxy endpoints when running via dashboard (avoids CORS issues)
        const isLocalDashboard = window.location.port === '8080' || window.location.pathname.includes('dashboard');
        const VALIDATOR_RPCS = isLocalDashboard ? [
            '/rpc/alice',   // Proxied to 51.79.26.123:9944
            '/rpc/bob',     // Proxied to 51.79.26.168:9944
            '/rpc/charlie'  // Proxied to 209.38.225.4:9944
        ] : [
            'http://51.79.26.123:9944',  // Alice - direct (for standalone)
            'http://51.79.26.168:9944',  // Bob
            'http://209.38.225.4:9944'   // Charlie
        ];

        // Fetch peers from a remote RPC endpoint
        async function fetchRemotePeers(rpcUrl) {
            try {
                const res = await fetch(rpcUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: 1, jsonrpc: '2.0', method: 'system_peers', params: [] })
                });
                const data = await res.json();
                return data.result || [];
            } catch (e) {
                return [];
            }
        }

        // Fetch and display peer connections with NETWORK-WIDE auto-discovery
        async function updatePeerConnections() {
            const container = document.getElementById('peersList');
            if (!container) return;

            try {
                // Get local peers first
                const localPeers = await rpc('system_peers') || [];

                // Query all production validators to discover the FULL network
                const allRemotePeers = await Promise.all(VALIDATOR_RPCS.map(url => fetchRemotePeers(url)));

                // Merge all peers into a unique set by peerId
                const peerMap = new Map();

                // Add local peers
                for (const peer of localPeers) {
                    peerMap.set(peer.peerId, { ...peer, directConnection: true });
                }

                // Add remote peers (discovered from validators)
                for (const remotePeerList of allRemotePeers) {
                    for (const peer of remotePeerList) {
                        if (!peerMap.has(peer.peerId)) {
                            peerMap.set(peer.peerId, { ...peer, directConnection: false });
                        }
                    }
                }

                // Filter out our own peerId
                const myPeerId = await rpc('system_localPeerId');
                peerMap.delete(myPeerId);

                const allPeers = Array.from(peerMap.values());

                if (allPeers.length === 0) {
                    discoveredPeers = [];
                    container.innerHTML = `<div class="info-row"><span class="info-label" style="color: var(--accent-warning);">No peers discovered</span></div>`;
                    return;
                }

                // Build discovered peers list with geolocation
                const newDiscoveredPeers = [];

                for (const peer of allPeers) {
                    const peerId = peer.peerId;
                    const known = KNOWN_VALIDATORS[peerId];

                    // Get IP from known validators or try to extract from multiaddr
                    let ip = known?.ip || null;

                    // Get geolocation if we have an IP
                    let geo = { city: '', country: '', isp: '' };
                    if (ip) {
                        geo = await geolocateIP(ip);
                    }

                    // Determine location - use known location, or geo lookup, or "Behind NAT"
                    let locationStr = known?.location || '';
                    if (!locationStr && geo.city && geo.country) {
                        locationStr = `${geo.city}, ${geo.country}`;
                    } else if (!locationStr && geo.city) {
                        locationStr = geo.city;
                    } else if (!locationStr) {
                        locationStr = peer.roles === 'AUTHORITY' ? 'Community Validator' : 'Behind NAT';
                    }

                    // Build peer info
                    const peerInfo = {
                        peerId: peerId,
                        name: known?.name || `Node ${peerId.substring(peerId.length - 4)}`,
                        ip: ip || 'Private',
                        location: locationStr,
                        provider: known?.provider || geo.isp || '',
                        color: known?.color || PEER_COLORS[newDiscoveredPeers.length % PEER_COLORS.length],
                        tier: known?.tier || 2,
                        role: peer.roles === 'AUTHORITY' ? 'Validator' : 'Full Node',
                        bestBlock: peer.bestNumber || 0,
                        directConnection: peer.directConnection
                    };

                    newDiscoveredPeers.push(peerInfo);
                }

                // Sort: validators first, then by name
                newDiscoveredPeers.sort((a, b) => {
                    if (a.role === 'Validator' && b.role !== 'Validator') return -1;
                    if (b.role === 'Validator' && a.role !== 'Validator') return 1;
                    return a.name.localeCompare(b.name);
                });

                discoveredPeers = newDiscoveredPeers;

                // Render peer list
                container.innerHTML = discoveredPeers.map(peer => `
                    <div class="info-row" style="padding: 8px 0; border-bottom: 1px solid var(--bg-surface); opacity: ${peer.directConnection ? '1' : '0.7'};">
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <span style="font-size: 12px; font-family: 'Orbitron', monospace;">
                                <span style="color: ${peer.color}; font-weight: 600;">${peer.name}</span>
                                ${!peer.directConnection ? '<span style="color: var(--text-muted); font-size: 9px; margin-left: 4px;">(via network)</span>' : ''}
                            </span>
                            <span style="color: ${peer.role === 'Validator' ? 'var(--accent-success)' : 'var(--text-muted)'}; font-size: 10px; font-weight: ${peer.role === 'Validator' ? 'bold' : 'normal'};">
                                ${peer.role === 'Validator' ? 'VALIDATOR' : 'NODE'}
                            </span>
                        </div>
                        <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
                            ðŸ“ ${peer.location} â€¢ Block #${peer.bestBlock.toLocaleString()}
                        </div>
                    </div>
                `).join('');

            } catch (e) {
                discoveredPeers = [];
                container.innerHTML = `<div class="info-row"><span class="info-label" style="color: var(--accent-danger);">Error: ${e.message}</span></div>`;
            }
        }

        // Calculate and update network health
        async function updateNetworkHealth() {
            const healthEl = document.getElementById('networkHealth');
            const finalizedEl = document.getElementById('networkFinalized');
            if (!healthEl) return;

            try {
                const health = await rpc('system_health');
                const finalizedHash = await rpc('chain_getFinalizedHead');

                if (!health) {
                    healthEl.textContent = 'OFFLINE';
                    healthEl.style.color = 'var(--accent-danger)';
                    return;
                }

                // Calculate health score based on peers and sync status
                const peerCount = health.peers || 0;
                const isSyncing = health.isSyncing;

                let healthStatus = 'CRITICAL';
                let healthColor = 'var(--accent-danger)';

                if (peerCount >= 2 && !isSyncing) {
                    healthStatus = 'OPTIMAL';
                    healthColor = 'var(--accent-success)';
                } else if (peerCount >= 1) {
                    healthStatus = 'DEGRADED';
                    healthColor = 'var(--accent-warning)';
                } else if (isSyncing) {
                    healthStatus = 'SYNCING';
                    healthColor = 'var(--lcars-blue-light)';
                }

                healthEl.textContent = healthStatus;
                healthEl.style.color = healthColor;

                // Update finalized block
                if (finalizedHash && finalizedEl) {
                    const finalizedHeader = await rpc('chain_getHeader', [finalizedHash]);
                    if (finalizedHeader?.number) {
                        const blockNum = parseInt(finalizedHeader.number, 16);
                        finalizedEl.textContent = blockNum.toLocaleString();
                    }
                }
            } catch (e) {
                healthEl.textContent = 'ERROR';
                healthEl.style.color = 'var(--accent-danger)';
            }
        }

        // Initialize network panel
        function initNetworkPanel() {
            updateValidatorNodes();
            drawNetworkMesh();
            updatePeerConnections();
            updateNetworkHealth();

            // Update peer connections, validator cards, and health every 10 seconds
            setInterval(() => {
                updatePeerConnections();
                updateValidatorNodes(); // Refresh cards with connection status
                updateNetworkHealth();
            }, 10000);
        }

        // Quantum Status
        async function updateQuantumStatus() {
            try {
                const res = await fetch(config.qkd + '/health');
                document.getElementById('qkdStatus').classList.toggle('offline', !res.ok);
                document.getElementById('qkdStatusText').textContent = res.ok ? 'Online' : 'Offline';
            } catch {
                document.getElementById('qkdStatus').classList.add('offline');
                document.getElementById('qkdStatusText').textContent = 'Offline';
            }

            try {
                const res = await fetch(config.hub + '/api/health');
                document.getElementById('hubStatus').classList.toggle('offline', !res.ok);
                document.getElementById('hubStatusText').textContent = res.ok ? 'Online' : 'Offline';
                if (res.ok) {
                    const health = await res.json();
                    if (health.sources) {
                        document.getElementById('hubSources').textContent = health.sources.filter(s => s.healthy).length + '/' + health.sources.length;
                    }
                }
            } catch {
                document.getElementById('hubStatus').classList.add('offline');
                document.getElementById('hubStatusText').textContent = 'Offline';
            }
        }

        // Settings
        function saveSettings() {
            config.rpc = document.getElementById('settingsRpc').value;
            config.qkd = document.getElementById('settingsQkd').value;
            config.hub = document.getElementById('settingsHub').value;
            config.controller = document.getElementById('settingsController').value;
            Object.entries(config).forEach(([k, v]) => localStorage.setItem(k, v));
            log('Settings saved', 'info');
            updateStatus();
        }

        function loadSettings() {
            document.getElementById('settingsRpc').value = config.rpc;
            document.getElementById('settingsQkd').value = config.qkd;
            document.getElementById('settingsHub').value = config.hub;
            document.getElementById('settingsController').value = config.controller;
        }

        // Init
        async function init() {
            console.log('init() starting');
            try {
                loadSettings();
                loadAvatar();
                loadMyAccount();  // Load saved account address
                updateAgentModeUI();
            } catch(e) {
                console.error('init setup error:', e);
            }
            log('Connecting to ' + RPC, 'info');

            console.log('Calling fetchAllData...');
            // Fetch all data immediately
            await fetchAllData();
            console.log('fetchAllData complete');

            // Initialize network panel with toroidal mesh visualization
            initNetworkPanel();

            // Initialize governance panel
            refreshProposals();

            // Initialize rewards panel
            refreshRewards();

            // Check faucet service status
            checkFaucetService();

            // Check quantum status
            updateQuantumStatus();

            // Update every 5 seconds
            setInterval(fetchAllData, 5000);
            setInterval(updateQuantumStatus, 15000);
            setInterval(checkAutoStake, 30000);

            // Refresh governance every 30 seconds
            setInterval(refreshProposals, 30000);

            log('Dashboard initialized - all panels active', 'info');
        }

        // Single function to fetch all node data
        async function fetchAllData() {
            console.log('fetchAllData called');
            try {
                // 1. Health check
                console.log('Calling system_health...');
                const health = await rpc('system_health');
                console.log('Health result:', health);

                const $ = id => document.getElementById(id);

                if (!health) {
                    console.log('No health - marking offline');
                    $('nodeProcessStatus')?.classList.add('offline');
                    $('nodeProcessText') && ($('nodeProcessText').textContent = 'Offline');
                    $('statusDot')?.classList.remove('connected');
                    return;
                }

                console.log('Setting UI with health data');
                $('nodeProcessStatus')?.classList.remove('offline');
                $('nodeProcessText') && ($('nodeProcessText').textContent = 'Running');
                $('statusDot')?.classList.add('connected');
                $('peerCount') && ($('peerCount').textContent = health.peers);
                $('networkPeers') && ($('networkPeers').textContent = health.peers);
                $('syncStatus') && ($('syncStatus').textContent = health.isSyncing ? 'Syncing' : 'Synced');

                // 2. Block height
                const header = await rpc('chain_getHeader');
                if (header?.number) {
                    const blockNum = parseInt(header.number, 16);
                    $('blockHeight') && ($('blockHeight').textContent = blockNum.toLocaleString());
                    $('networkBest') && ($('networkBest').textContent = blockNum.toLocaleString());
                }

                // 3. Node info
                const chain = await rpc('system_chain');
                if (chain) $('chainName') && ($('chainName').textContent = chain);

                const name = await rpc('system_name');
                if (name) $('nodeName') && ($('nodeName').textContent = name);

                const version = await rpc('system_version');
                if (version) $('nodeVersion') && ($('nodeVersion').textContent = version);

                const runtime = await rpc('state_getRuntimeVersion');
                if (runtime?.specVersion) {
                    $('runtimeVersion') && ($('runtimeVersion').textContent = 'v' + runtime.specVersion);
                }

                $('rpcEndpoint') && ($('rpcEndpoint').textContent = RPC);

                // 4. Recent blocks
                await loadRecentBlocks();

                connected = true;
                $('footerStatus') && ($('footerStatus').textContent = 'Connected');

            } catch (e) {
                console.error('fetchAllData error:', e);
            }
        }

        // Load recent blocks with author info
        async function loadRecentBlocks() {
            const container = document.getElementById('recentBlocksContainer');
            const header = await rpc('chain_getHeader');
            if (!header) return;

            const currentBlock = parseInt(header.number, 16);
            let html = '';

            // Map known validator public keys to names
            const validatorNames = {
                '0x24a5': 'Alice',
                '0xb8e0': 'Bob',
                '0x8c': 'Charlie'
            };

            for (let i = 0; i < 5; i++) {
                const blockNum = currentBlock - i;
                const hash = await rpc('chain_getBlockHash', [blockNum]);
                if (!hash) continue;

                const block = await rpc('chain_getBlock', [hash]);
                const extCount = block?.block?.extrinsics?.length || 0;

                // Try to identify block author from Aura
                let authorLabel = '';
                const authorIndex = blockNum % 2; // Aura round-robin with 2 authorities
                const authorColors = ['#ff9966', '#66ccff', '#99ff99'];
                const authorName = ['Alice', 'Bob', 'Charlie'][authorIndex] || '?';
                authorLabel = `<span style="color:${authorColors[authorIndex]};font-size:10px;margin-left:8px;">by ${authorName}</span>`;

                html += `<div class="info-row" style="padding:8px 0;border-bottom:1px solid var(--bg-surface);">
                    <div style="display:flex;justify-content:space-between;width:100%">
                        <span style="color:var(--lcars-gold);font-family:'Orbitron',monospace;font-size:13px">#${blockNum.toLocaleString()}${authorLabel}</span>
                        <span style="color:var(--accent-success);font-size:12px">${extCount} ext</span>
                    </div>
                    <div style="width:100%;margin-top:4px">
                        <span style="color:var(--text-muted);font-size:10px;font-family:'JetBrains Mono',monospace">${hash.slice(0,10)}...${hash.slice(-6)}</span>
                    </div>
                </div>`;
            }

            container.innerHTML = html || '<div class="info-row"><span class="info-label">No blocks</span></div>';
        }

        // Query current validators (authorities)
        async function queryValidators() {
            try {
                // Query Aura authorities
                const authorities = await rpc('state_call', ['AuraApi_authorities', '0x']);
                if (authorities) {
                    log(`Aura authorities: ${authorities.substring(0, 40)}...`, 'info');
                }
                return authorities;
            } catch (e) {
                console.error('Failed to query validators:', e);
                return null;
            }
        }

        document.addEventListener('DOMContentLoaded', init);

        // ===========================================
        // PROOFS PANEL FUNCTIONS
        // ===========================================

        // Generate random hex inputs for Pedersen demo
        function generateRandomInputs() {
            const randomHex = (len) => Array.from(crypto.getRandomValues(new Uint8Array(len)))
                .map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('proofEntropy').value = randomHex(32);
            document.getElementById('proofBlinding').value = randomHex(32);
        }

        // Simulated test runner - 164 tests across 8 pallets
        function runProofTests() {
            const consoleEl = document.getElementById('proofConsole');
            consoleEl.innerHTML = '<span style="color: #888;">$ cargo test --workspace</span>\n\n';
            consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">Compiling 8 pallets...</span>\n';

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-pedersen-commitment v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-ricardian-contracts v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-notarial v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-academic-vouch v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-fideicommis v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-stablecoin v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-relay-coordination v1.0.0</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">   Compiling pallet-validator-entropy v1.0.0</span>\n\n';
            }, 500);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 21 tests (pallet-pedersen-commitment)</span>\n';
                ['test_create_commitment_point_deterministic', 'test_verify_commitment_correct',
                 'test_information_theoretic_hiding', 'test_binding_property'].forEach((t, i) => {
                    setTimeout(() => {
                        consoleEl.innerHTML += `<span style="color: var(--accent-success);">test ${t} ... ok</span>\n`;
                        consoleEl.scrollTop = consoleEl.scrollHeight;
                    }, i * 50);
                });
            }, 1000);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: #888;">... +17 more tests passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 32 tests (pallet-ricardian-contracts)</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::create_contract_works ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::sign_contract_works ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... +30 more tests passed</span>\n\n';
            }, 1600);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 29 tests (pallet-notarial)</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::attest_document_works ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::witness_attestation_certification ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... +27 more tests passed</span>\n\n';
            }, 2000);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 32 tests (pallet-academic-vouch)</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::vouch_for_applicant_works ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... +31 more tests passed</span>\n\n';
            }, 2400);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 18 tests (pallet-fideicommis)</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent-success);">test tests::create_trust_works ... ok</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... +17 more tests passed</span>\n\n';
            }, 2800);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 14 tests (pallet-stablecoin)</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... all passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 11 tests (pallet-relay-coordination)</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... all passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">running 7 tests (pallet-validator-entropy)</span>\n';
                consoleEl.innerHTML += '<span style="color: #888;">... all passed</span>\n\n';
            }, 3200);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--accent-success); font-weight: bold;">test result: ok. 164 passed; 0 failed; 0 ignored</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--lcars-gold);">   Finished in 0.05s</span>\n';
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }, 3800);
        }

        // Compute Pedersen commitment (simulated - actual BLS12-381 would need WASM)
        async function computePedersenCommitment() {
            const entropyHex = document.getElementById('proofEntropy').value;
            const blindingHex = document.getElementById('proofBlinding').value;

            // Validate hex inputs
            if (!/^[0-9a-fA-F]{64}$/.test(entropyHex) || !/^[0-9a-fA-F]{64}$/.test(blindingHex)) {
                document.getElementById('proofCommitmentResult').textContent = 'Invalid hex (need 64 chars)';
                document.getElementById('proofCommitmentResult').style.color = 'var(--accent-danger)';
                return;
            }

            // Show computing state
            document.getElementById('proofCommitmentResult').textContent = 'Computing...';
            document.getElementById('proofCommitmentResult').style.color = 'var(--lcars-gold)';

            // Simulate BLS12-381 G1 point computation
            // In production this would call the actual palletPedersenCommitment.createCommitmentPoint
            await new Promise(r => setTimeout(r, 500));

            // Generate deterministic pseudo-commitment (actual impl would use BLS12-381)
            const combined = entropyHex + blindingHex;
            const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined));
            const hashArray = Array.from(new Uint8Array(hash));

            // Extend to 48 bytes (G1 compressed point size)
            const hash2 = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined + '2'));
            const hash2Array = Array.from(new Uint8Array(hash2));

            const commitment = [...hashArray, ...hash2Array.slice(0, 16)]
                .map(b => b.toString(16).padStart(2, '0')).join('');

            document.getElementById('proofCommitmentResult').textContent = commitment;
            document.getElementById('proofCommitmentResult').style.color = 'var(--lcars-blue-light)';
        }

        // Compute document hash
        async function computeDocumentHash() {
            const text = document.getElementById('proofDocText').value;
            const encoder = new TextEncoder();
            const data = encoder.encode(text);

            // Use SHA-256 (Blake2 would need a library)
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            document.getElementById('proofDocHash').textContent = hashHex;
            document.getElementById('proofDocVerify').textContent = 'Hash computed - ready for verification';
            document.getElementById('proofDocVerify').style.color = 'var(--lcars-gold)';

            // Store for verification
            window.lastDocHash = hashHex;
            window.lastDocText = text;
        }

        // Verify document hash
        async function verifyDocumentHash() {
            const text = document.getElementById('proofDocText').value;
            const displayedHash = document.getElementById('proofDocHash').textContent;

            if (displayedHash === '---') {
                document.getElementById('proofDocVerify').textContent = 'Compute hash first';
                document.getElementById('proofDocVerify').style.color = 'var(--accent-danger)';
                return;
            }

            // Recompute hash
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const recomputedHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            if (recomputedHash === displayedHash) {
                document.getElementById('proofDocVerify').innerHTML = '<span style="color: var(--accent-success);">âœ“ VERIFIED - Hash matches document</span>';
            } else {
                document.getElementById('proofDocVerify').innerHTML = '<span style="color: var(--accent-danger);">âœ— MISMATCH - Document has been modified</span>';
            }
        }

        // ===========================================
        // REPORTER FUNCTIONS
        // ===========================================
        let currentReporterId = localStorage.getItem('reporterId') || null;

        async function registerReporter() {
            const reporterIdInput = document.getElementById('reporterId');
            const accountInput = document.getElementById('reporterAccount');
            const reporterId = reporterIdInput.value.trim();
            const account = accountInput.value.trim();

            if (!reporterId || !account) {
                log('Please enter Reporter ID and Account Address', 'error');
                return;
            }

            const feeds = [];
            if (document.getElementById('feedCADUSD').checked) feeds.push('CAD/USD');
            if (document.getElementById('feedQMHYUSD').checked) feeds.push('QMHY/USD');
            if (document.getElementById('feedQCADCAD').checked) feeds.push('QCAD/CAD');

            const btn = document.getElementById('registerReporterBtn');
            btn.disabled = true;
            btn.textContent = 'Registering...';

            try {
                log(`Registering as reporter: ${reporterId}...`, 'info');

                const result = await rpcCall('oracle_registerReporter', [reporterId, account, feeds]);

                if (result && !result.error) {
                    currentReporterId = reporterId;
                    localStorage.setItem('reporterId', reporterId);
                    log(`Successfully registered as reporter: ${reporterId}`, 'success');
                    updateReporterStatus();
                    fetchReporters();
                } else {
                    log(`Registration failed: ${result?.error?.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                log(`Registration error: ${e.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Register as Reporter';
            }
        }

        async function submitPrice() {
            if (!currentReporterId) {
                log('Please register as a reporter first', 'warning');
                return;
            }

            const feed = document.getElementById('priceFeed').value;
            const priceStr = document.getElementById('priceValue').value.trim();

            if (!priceStr) {
                log('Please enter a price value', 'error');
                return;
            }

            const price = parseFloat(priceStr);
            if (isNaN(price) || price <= 0) {
                log('Invalid price value', 'error');
                return;
            }

            const btn = document.getElementById('submitPriceBtn');
            btn.disabled = true;
            btn.textContent = 'Submitting...';

            try {
                log(`Submitting price for ${feed}: ${price}`, 'info');

                const result = await rpcCall('oracle_submitPrice', [{
                    reporter_id: currentReporterId,
                    feed: feed,
                    price: Math.round(price * 100000000) // 8 decimals
                }]);

                if (result && !result.error) {
                    log(`Price submitted successfully for ${feed}`, 'success');
                    updateReporterStatus();
                    fetchOraclePrices();
                } else {
                    log(`Price submission failed: ${result?.error?.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                log(`Price submission error: ${e.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Submit Price';
            }
        }

        async function updateReporterStatus() {
            if (!currentReporterId) {
                document.getElementById('reporterStatus').textContent = 'Not Registered';
                document.getElementById('reporterStatus').style.color = 'var(--text-muted)';
                document.getElementById('reporterReputation').textContent = '--';
                document.getElementById('reporterSubmissions').textContent = '0';
                document.getElementById('reporterSuccessRate').textContent = '--%';
                return;
            }

            try {
                const info = await rpcCall('oracle_getReporterInfo', [currentReporterId]);
                if (info) {
                    document.getElementById('reporterStatus').textContent = info.status || 'Active';
                    document.getElementById('reporterStatus').style.color =
                        info.status === 'Active' ? 'var(--accent-success)' : 'var(--accent-warning)';
                    document.getElementById('reporterReputation').textContent = `${info.reputation || 0}%`;
                    document.getElementById('reporterSubmissions').textContent = info.total_submissions || 0;

                    const total = info.total_submissions || 0;
                    const accepted = info.accepted_submissions || 0;
                    const rate = total > 0 ? Math.round((accepted / total) * 100) : 0;
                    document.getElementById('reporterSuccessRate').textContent = `${rate}%`;
                }
            } catch (e) {
                console.error('Error fetching reporter status:', e);
            }
        }

        async function fetchOraclePrices() {
            try {
                const prices = await rpcCall('oracle_getPrices', []);
                if (prices) {
                    if (prices['CAD/USD']) {
                        document.getElementById('priceCADUSD').textContent =
                            `$${(prices['CAD/USD'] / 100000000).toFixed(8)}`;
                    }
                    if (prices['QMHY/USD']) {
                        document.getElementById('priceQMHYUSD').textContent =
                            `$${(prices['QMHY/USD'] / 100000000).toFixed(8)}`;
                    }
                    if (prices['QCAD/CAD']) {
                        document.getElementById('priceQCADCAD').textContent =
                            `$${(prices['QCAD/CAD'] / 100000000).toFixed(8)}`;
                    }
                }
            } catch (e) {
                console.error('Error fetching oracle prices:', e);
            }
        }

        async function fetchReporters() {
            try {
                const reporters = await rpcCall('oracle_getAllReporters', []);
                const container = document.getElementById('reportersList');

                if (!reporters || reporters.length === 0) {
                    container.innerHTML = `
                        <div class="info-row">
                            <span class="info-label" style="color: var(--text-muted);">No reporters registered</span>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = reporters.map(r => `
                    <div class="info-row">
                        <span class="info-label">${r.id}</span>
                        <span class="info-value" style="color: ${r.status === 'Active' ? 'var(--accent-success)' : 'var(--text-muted)'};">
                            ${r.reputation || 0}% rep
                        </span>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Error fetching reporters:', e);
            }
        }

        // Auto-refresh reporter panel every 30 seconds
        setInterval(() => {
            if (document.getElementById('panel-reporter')?.classList.contains('active')) {
                updateReporterStatus();
                fetchOraclePrices();
                fetchReporters();
            }
        }, 30000);

        // Initialize reporter panel when shown
        const originalShowPanel = showPanel;
        showPanel = function(name) {
            originalShowPanel(name);
            if (name === 'reporter') {
                updateReporterStatus();
                fetchOraclePrices();
                fetchReporters();
            }
            if (name === 'messages') {
                checkMessagingStatus();
            }
        };

        // ===========================================
        // MESSAGING FUNCTIONS (Post-Quantum Encrypted)
        // ===========================================

        const MESSAGING_URL = window.location.protocol + '//' + window.location.hostname + ':9955';
        let messagingInitialized = false;
        let myFingerprint = null;

        async function checkMessagingStatus() {
            try {
                const response = await fetch(MESSAGING_URL + '/messaging/bundle');
                if (response.ok) {
                    const data = await response.json();
                    messagingInitialized = true;
                    // API returns 'bundle' as base64, generate fingerprint from it
                    const bundleB64 = data.bundle || data.bundle_base64;
                    myFingerprint = data.fingerprint || await generateFingerprint(bundleB64);
                    document.getElementById('msgFingerprint').textContent = myFingerprint;
                    document.getElementById('initMsgBtn').textContent = 'INITIALIZED';
                    document.getElementById('initMsgBtn').disabled = true;
                    await refreshMessages();
                    await refreshPeers();
                }
            } catch (e) {
                console.log('Messaging not initialized yet');
            }
        }

        // Generate a short fingerprint from bundle data
        async function generateFingerprint(bundleB64) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(bundleB64);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.slice(0, 8).map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (e) {
                return bundleB64.substring(0, 16);
            }
        }

        async function initMessaging() {
            const btn = document.getElementById('initMsgBtn');
            btn.textContent = 'INITIALIZING...';
            btn.disabled = true;

            try {
                const response = await fetch(MESSAGING_URL + '/messaging/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    const data = await response.json();
                    messagingInitialized = true;
                    const bundleB64 = data.bundle || data.bundle_base64 || '';
                    myFingerprint = data.fingerprint || await generateFingerprint(bundleB64);
                    document.getElementById('msgFingerprint').textContent = myFingerprint;
                    btn.textContent = 'INITIALIZED';
                    terminalLog('Messaging initialized. Fingerprint: ' + myFingerprint, 'success');
                    await refreshMessages();
                } else {
                    const err = await response.text();
                    terminalLog('Init failed: ' + err, 'error');
                    btn.textContent = 'INITIALIZE';
                    btn.disabled = false;
                }
            } catch (e) {
                terminalLog('Messaging init error: ' + e.message, 'error');
                btn.textContent = 'INITIALIZE';
                btn.disabled = false;
            }
        }

        async function refreshMessages() {
            if (!messagingInitialized) {
                terminalLog('Initialize messaging first', 'warn');
                return;
            }

            try {
                const response = await fetch(MESSAGING_URL + '/messaging/inbox');
                if (!response.ok) throw new Error('Failed to fetch inbox');

                const messages = await response.json();
                const chatArea = document.getElementById('msgChatArea');

                if (messages.length === 0) {
                    chatArea.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 20px;">No messages yet. Add peers and start communicating!</div>';
                    document.getElementById('msgUnreadCount').textContent = '0';
                    return;
                }

                messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                chatArea.innerHTML = messages.map(msg => {
                    const time = new Date(msg.timestamp).toLocaleTimeString();
                    const sender = msg.from_fingerprint.substring(0, 8);
                    const typeColor = msg.message_type === 'alert' ? 'var(--accent-danger)' :
                                      msg.message_type === 'maintenance' ? 'var(--accent-warning)' :
                                      'var(--lcars-gold)';
                    return `
                        <div style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.02); border-radius: 4px; border-left: 3px solid ${typeColor};">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: var(--lcars-blue); font-weight: bold;">${sender}...</span>
                                <span style="color: var(--text-muted); font-size: 10px;">${time}</span>
                            </div>
                            <div style="color: var(--text-primary);">${escapeHtml(msg.content)}</div>
                            <div style="color: var(--text-muted); font-size: 9px; margin-top: 4px;">[${msg.message_type}]</div>
                        </div>
                    `;
                }).join('');

                document.getElementById('msgUnreadCount').textContent = messages.length;
                chatArea.scrollTop = chatArea.scrollHeight;
            } catch (e) {
                terminalLog('Error fetching messages: ' + e.message, 'error');
            }
        }

        async function refreshPeers() {
            try {
                const response = await fetch(MESSAGING_URL + '/messaging/peers');
                if (!response.ok) return;

                const peers = await response.json();
                const peerList = document.getElementById('msgPeerList');
                document.getElementById('msgPeerCount').textContent = peers.length;

                if (peers.length === 0) {
                    peerList.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No peers added yet</div>';
                    return;
                }

                peerList.innerHTML = peers.map(p => `
                    <div style="padding: 6px 0; border-bottom: 1px solid var(--bg-surface);">
                        <div style="color: var(--lcars-gold); font-family: monospace; font-size: 11px;">${p.fingerprint}</div>
                        <div style="color: var(--text-muted); font-size: 10px;">Added: ${new Date(p.added_at).toLocaleDateString()}</div>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Error fetching peers:', e);
            }
        }

        async function sendMessage() {
            if (!messagingInitialized) {
                terminalLog('Initialize messaging first', 'warn');
                return;
            }

            const recipient = document.getElementById('msgRecipient').value.trim();
            const content = document.getElementById('msgContent').value.trim();
            const msgType = document.getElementById('msgType').value;

            if (!recipient || !content) {
                terminalLog('Please enter recipient and message', 'warn');
                return;
            }

            try {
                const response = await fetch(MESSAGING_URL + '/messaging/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        peer_fingerprint: recipient,
                        content: content,
                        message_type: msgType
                    })
                });

                if (response.ok) {
                    terminalLog('Message sent to ' + recipient.substring(0, 8) + '...', 'success');
                    document.getElementById('msgContent').value = '';
                    await refreshMessages();
                } else {
                    const err = await response.text();
                    terminalLog('Send failed: ' + err, 'error');
                }
            } catch (e) {
                terminalLog('Send error: ' + e.message, 'error');
            }
        }

        async function addPeer() {
            if (!messagingInitialized) {
                terminalLog('Initialize messaging first', 'warn');
                return;
            }

            const bundleBase64 = document.getElementById('msgPeerBundle').value.trim();
            if (!bundleBase64) {
                terminalLog('Please paste peer bundle', 'warn');
                return;
            }

            try {
                // Try both field names for compatibility
                const response = await fetch(MESSAGING_URL + '/messaging/peers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bundle: bundleBase64, bundle_base64: bundleBase64 })
                });

                if (response.ok) {
                    const data = await response.json();
                    const fp = data.fingerprint || await generateFingerprint(bundleBase64);
                    terminalLog('Peer added: ' + fp, 'success');
                    document.getElementById('msgPeerBundle').value = '';
                    await refreshPeers();
                } else {
                    const err = await response.text();
                    terminalLog('Add peer failed: ' + err, 'error');
                }
            } catch (e) {
                terminalLog('Add peer error: ' + e.message, 'error');
            }
        }

        async function showMyBundle() {
            if (!messagingInitialized) {
                terminalLog('Initialize messaging first', 'warn');
                return;
            }

            try {
                const response = await fetch(MESSAGING_URL + '/messaging/bundle');
                if (!response.ok) throw new Error('Failed to fetch bundle');

                const data = await response.json();
                document.getElementById('msgMyBundle').style.display = 'block';
                document.getElementById('msgBundleText').value = data.bundle || data.bundle_base64;
                terminalLog('Bundle displayed. Share with peers to enable messaging.', 'info');
            } catch (e) {
                terminalLog('Error fetching bundle: ' + e.message, 'error');
            }
        }

        function copyBundle() {
            const bundleText = document.getElementById('msgBundleText');
            bundleText.select();
            document.execCommand('copy');
            terminalLog('Bundle copied to clipboard!', 'success');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-refresh messages every 10 seconds when panel is active
        setInterval(() => {
            if (document.getElementById('panel-messages')?.classList.contains('active') && messagingInitialized) {
                refreshMessages();
                refreshPeers();
            }
        }, 10000);

        // ===========================================
        // PERSISTENT CHAT WIDGET FUNCTIONS
        // ===========================================

        let chatExpanded = false;
        let chatInitialized = false;
        let chatFingerprint = null;

        // Known validators for chat (messaging fingerprints)
        const CHAT_VALIDATORS = {
            '97e3988b8c7e6f40': 'Alice',
            '6bafb1037350eebd': 'Bob'
        };

        function toggleChat() {
            chatExpanded = !chatExpanded;
            const msgArea = document.getElementById('chatMessages');
            const icon = document.getElementById('chatToggleIcon');
            if (chatExpanded) {
                msgArea.style.height = '200px';
                msgArea.style.padding = '8px';
                icon.textContent = 'â–¼';
                refreshChatMessages();
            } else {
                msgArea.style.height = '0';
                msgArea.style.padding = '0';
                icon.textContent = 'â–²';
            }
        }

        async function initChatMessaging() {
            const btn = document.getElementById('chatInitBtn');
            btn.textContent = '...';
            btn.disabled = true;

            try {
                // First try to get existing bundle
                let response = await fetch(MESSAGING_URL + '/messaging/bundle');

                if (!response.ok) {
                    // Initialize if not exists
                    response = await fetch(MESSAGING_URL + '/messaging/init', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }

                if (response.ok) {
                    const data = await response.json();
                    chatInitialized = true;
                    const bundleB64 = data.bundle || data.bundle_base64 || '';
                    chatFingerprint = data.fingerprint || await generateFingerprint(bundleB64);
                    document.getElementById('chatFingerprint').textContent = chatFingerprint;
                    btn.style.display = 'none'; // Hide init button
                    updateValidatorDropdown();
                    refreshChatMessages();
                } else {
                    btn.textContent = 'ERR';
                    btn.style.background = '#ff4444';
                    btn.disabled = false;
                }
            } catch (e) {
                console.error('Chat init error:', e);
                document.getElementById('chatFingerprint').textContent = 'Offline';
                btn.textContent = 'INIT';
                btn.disabled = false;
            }
        }

        // Update dropdown to exclude self
        function updateValidatorDropdown() {
            const select = document.getElementById('chatRecipient');
            select.innerHTML = '<option value="">Select recipient...</option><option value="ALL">-- ALL VALIDATORS --</option>';
            for (const [fp, name] of Object.entries(CHAT_VALIDATORS)) {
                if (fp !== chatFingerprint) {
                    select.innerHTML += `<option value="${fp}">${name} (${fp.substring(0,8)})</option>`;
                }
            }
        }

        // Remote validator endpoints for message sync
        const VALIDATOR_MESSAGING = {
            'Alice': 'http://51.79.26.123:9955',
            'Bob': 'http://51.79.26.168:9955'
        };

        async function refreshChatMessages() {
            if (!chatInitialized) return;

            try {
                let allMessages = [];

                // Fetch local inbox and outbox
                const [inboxResp, outboxResp] = await Promise.all([
                    fetch(MESSAGING_URL + '/messaging/inbox'),
                    fetch(MESSAGING_URL + '/messaging/outbox')
                ]);

                if (inboxResp.ok) {
                    const inboxData = await inboxResp.json();
                    const inboxMsgs = (inboxData.messages || []).map(m => ({...m, direction: 'in', source: 'local'}));
                    allMessages.push(...inboxMsgs);
                }

                if (outboxResp.ok) {
                    const outboxData = await outboxResp.json();
                    const outboxMsgs = (outboxData.messages || []).map(m => ({...m, direction: 'out', source: 'local'}));
                    allMessages.push(...outboxMsgs);
                }

                // POLL REMOTE VALIDATORS for messages TO this node
                for (const [name, url] of Object.entries(VALIDATOR_MESSAGING)) {
                    try {
                        const remoteResp = await fetch(url + '/messaging/outbox', { signal: AbortSignal.timeout(3000) });
                        if (remoteResp.ok) {
                            const remoteData = await remoteResp.json();
                            // Filter messages addressed to us
                            const toMe = (remoteData.messages || [])
                                .filter(m => m.to === chatFingerprint || m.to?.startsWith(chatFingerprint?.substring(0,8)))
                                .map(m => ({...m, direction: 'in', source: name, from: m.from || name}));
                            allMessages.push(...toMe);
                        }
                    } catch (e) {
                        // Remote validator offline, ignore
                    }
                }

                const chatArea = document.getElementById('chatMessages');
                const unreadBadge = document.getElementById('chatUnread');

                if (allMessages.length === 0) {
                    chatArea.innerHTML = '<div style="color: var(--text-muted); font-size: 10px; text-align: center; padding: 20px;">No messages yet. Send one!</div>';
                    unreadBadge.style.display = 'none';
                    return;
                }

                // Deduplicate by message ID
                const seen = new Set();
                allMessages = allMessages.filter(m => {
                    const key = m.id || (m.timestamp + m.content);
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });

                // Sort by timestamp
                allMessages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

                // Show received count
                const inboxCount = allMessages.filter(m => m.direction === 'in').length;
                if (inboxCount > 0) {
                    unreadBadge.textContent = inboxCount;
                    unreadBadge.style.display = 'inline';
                } else {
                    unreadBadge.style.display = 'none';
                }

                chatArea.innerHTML = allMessages.map(msg => {
                    const time = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    const isOutgoing = msg.direction === 'out';
                    const senderName = CHAT_VALIDATORS[msg.from] || msg.source || (msg.from || '').substring(0, 6);
                    const recipientName = CHAT_VALIDATORS[msg.to] || (msg.to || '').substring(0, 6);
                    const bgColor = isOutgoing ? 'rgba(0,100,200,0.15)' : 'rgba(255,153,0,0.1)';
                    const borderColor = isOutgoing ? '#6699ff' :
                                        (msg.message_type === 'Alert' ? '#ff4444' :
                                         msg.message_type === 'Maintenance' ? '#ffaa00' : '#ff9966');
                    const label = isOutgoing ? `You â†’ ${recipientName}` : `${senderName} â†’ You`;
                    const labelColor = isOutgoing ? '#66ff66' : '#ff9966';

                    return `
                        <div style="margin-bottom: 6px; padding: 6px; background: ${bgColor}; border-radius: 4px; border-left: 3px solid ${borderColor};">
                            <div style="display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 2px;">
                                <span style="color: ${labelColor}; font-weight: bold;">${label}</span>
                                <span style="color: #666;">${time}</span>
                            </div>
                            <div style="color: #eee; font-size: 11px;">${escapeHtml(msg.content)}</div>
                        </div>
                    `;
                }).join('');

                chatArea.scrollTop = chatArea.scrollHeight;
            } catch (e) {
                console.error('Chat refresh error:', e);
            }
        }

        async function sendChatMessage() {
            if (!chatInitialized) {
                alert('Click INIT first');
                return;
            }

            const recipientSelect = document.getElementById('chatRecipient');
            const recipient = recipientSelect.value;
            const content = document.getElementById('chatInput').value.trim();
            const msgType = document.getElementById('chatMsgType')?.value || 'text';

            if (!recipient || !content) {
                return;
            }

            // Get list of recipients
            const recipients = recipient === 'ALL'
                ? Object.keys(CHAT_VALIDATORS).filter(fp => fp !== chatFingerprint)
                : [recipient];

            let sentCount = 0;
            for (const fp of recipients) {
                try {
                    const response = await fetch(MESSAGING_URL + '/messaging/send', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            peer_fingerprint: fp,
                            content: content,
                            message_type: msgType
                        })
                    });
                    if (response.ok) sentCount++;
                } catch (e) {
                    console.error('Send error to', fp, e);
                }
            }

            if (sentCount > 0) {
                document.getElementById('chatInput').value = '';
                // Add to local display
                const chatArea = document.getElementById('chatMessages');
                const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const recipientLabel = recipient === 'ALL' ? 'ALL' : (CHAT_VALIDATORS[recipient] || recipient.substring(0,6));
                const typeColor = msgType === 'alert' ? '#ff4444' : msgType === 'maintenance' ? '#ffaa00' : '#6699ff';
                chatArea.innerHTML += `
                    <div style="margin-bottom: 6px; padding: 6px; background: rgba(0,100,200,0.15); border-radius: 4px; border-left: 2px solid ${typeColor};">
                        <div style="display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 2px;">
                            <span style="color: #66ff66;">You â†’ ${recipientLabel}</span>
                            <span style="color: #666;">${time}</span>
                        </div>
                        <div style="color: #ddd; font-size: 11px;">${escapeHtml(content)}</div>
                    </div>
                `;
                chatArea.scrollTop = chatArea.scrollHeight;

                // Expand chat if collapsed
                if (!chatExpanded) toggleChat();
            }
        }

        async function showChatBundle() {
            if (!chatInitialized) {
                alert('Click INIT first');
                return;
            }

            try {
                const response = await fetch(MESSAGING_URL + '/messaging/bundle');
                if (!response.ok) throw new Error('Failed');

                const data = await response.json();
                const bundle = data.bundle || data.bundle_base64;

                // Copy to clipboard
                navigator.clipboard.writeText(bundle).then(() => {
                    alert('Your bundle copied to clipboard!\\n\\nFingerprint: ' + chatFingerprint + '\\n\\nShare this with other validators so they can message you.');
                }).catch(() => {
                    prompt('Copy your bundle:', bundle);
                });
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        // Auto-refresh chat every 5 seconds
        setInterval(() => {
            if (chatInitialized) {
                refreshChatMessages();
            }
        }, 5000);

        // Try to initialize chat on page load
        setTimeout(initChatMessaging, 2000);
    </script>
</body>
</html>
